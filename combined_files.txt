/*************************************************************************

    File: alphaConversion.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(alphaConversion,[alphaConvert/2,
                           alphabeticVariants/2]).

:- use_module(comsemPredicates,[compose/3,
				memberList/2]).


/*========================================================================
   Alpha Conversion (introducing substitutions)
========================================================================*/

alphaConvert(F1,F2):-
   alphaConvert(F1,[],[]-_,F2).


/*========================================================================
   Alpha Conversion 
========================================================================*/

alphaConvert(X,Sub,Free1-Free2,Y):-
   var(X), 
   (
      memberList(sub(Z,Y),Sub),
      X==Z, !,
      Free2=Free1
   ;
      Y=X,
      Free2=[X|Free1]
   ).

alphaConvert(Expression,Sub,Free1-Free2,some(Y,F2)):-
   nonvar(Expression),
   Expression = some(X,F1),
   alphaConvert(F1,[sub(X,Y)|Sub],Free1-Free2,F2).

alphaConvert(Expression,Sub,Free1-Free2,all(Y,F2)):- 
   nonvar(Expression),
   Expression = all(X,F1),
   alphaConvert(F1,[sub(X,Y)|Sub],Free1-Free2,F2).

alphaConvert(Expression,Sub,Free1-Free2,lam(Y,F2)):- 
   nonvar(Expression),
   Expression = lam(X,F1),
   alphaConvert(F1,[sub(X,Y)|Sub],Free1-Free2,F2).

alphaConvert(Expression,Sub,Free1-Free3,que(Y,F3,F4)):-
   nonvar(Expression),
   Expression = que(X,F1,F2),
   alphaConvert(F1,[sub(X,Y)|Sub],Free1-Free2,F3),
   alphaConvert(F2,[sub(X,Y)|Sub],Free2-Free3,F4).

alphaConvert(F1,Sub,Free1-Free2,F2):-
   nonvar(F1),
   \+ F1 = some(_,_),
   \+ F1 = all(_,_),
   \+ F1 = lam(_,_),
   \+ F1 = que(_,_,_),
   compose(F1,Symbol,Args1),
   alphaConvertList(Args1,Sub,Free1-Free2,Args2),
   compose(F2,Symbol,Args2).


/*========================================================================
   Alpha Conversion (listwise)
========================================================================*/

alphaConvertList([],_,Free-Free,[]).

alphaConvertList([X|L1],Sub,Free1-Free3,[Y|L2]):-
   alphaConvert(X,Sub,Free1-Free2,Y),
   alphaConvertList(L1,Sub,Free2-Free3,L2).


/*========================================================================
   Alphabetic Variants
========================================================================*/

alphabeticVariants(Term1,Term2):-
   alphaConvert(Term1,[],[]-Free1,Term3),
   alphaConvert(Term2,[],[]-Free2,Term4),
   Free1==Free2,
   numbervars(Free1,0,N),
   numbervars(Term3,N,M),
   numbervars(Term4,N,M),
   Term3=Term4.


/*************************************************************************

    File: babyCurt.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(curt,[curt/0,infix/0,prefix/0]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
				printRepresentations/1]).

:- use_module(kellerStorage,[kellerStorage/2]).

:- use_module(curtPredicates,[curtHelp/0,
                              curtOutput/1,
                              updateReadings/1,
                              updateHistory/1,
                              clearHistory/0,
                              selectReadings/3]).


/*========================================================================
   Dynamic Predicates
========================================================================*/

:- dynamic history/1, readings/1.

history([]).
readings([]).


/*========================================================================
   Start Curt
========================================================================*/

curt:- 
   curtTalk(run).


/*========================================================================
   Control
========================================================================*/

curtTalk(quit).

curtTalk(run):-
   readLine(Input),
   curtUpdate(Input,CurtsMoves,State), 
   curtOutput(CurtsMoves),
   curtTalk(State).


/*========================================================================
   Update Curt's Information State
========================================================================*/

curtUpdate([],[clarify],run):- !.

curtUpdate([bye],[bye],quit):- !,
   updateReadings([]),
   clearHistory.

curtUpdate([new],[],run):- !,
   updateReadings([]),
   clearHistory.

curtUpdate([help],[],run):- !,
   curtHelp.

curtUpdate([infix],[],run):- !,
   infix.

curtUpdate([prefix],[],run):- !,
   prefix.

curtUpdate([select,X],[],run):-
   number(X),
   readings(R1),
   selectReadings(X,R1,R2), !,
   updateReadings(R2).

curtUpdate([readings],[],run):- !,
   readings(R),
   printRepresentations(R).

curtUpdate([history],[],run):- !,
   history(H),
   printRepresentations(H).

curtUpdate(Input,[accept],run):-
   kellerStorage(Input,Readings), !,
   updateHistory(Input),
   combine(Readings,NewReadings),
   updateReadings(NewReadings).

curtUpdate(_,[noparse],run).


/*========================================================================
   Combine New Utterances with History
========================================================================*/

combine(New,New):-
   readings([]).

combine(Readings,Updated):-
   readings([Old|_]),
   findall(and(Old,New),memberList(New,Readings),Updated).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> babyCurt.pl, by Patrick Blackburn and Johan Bos                     <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- curt.                - start a dialogue with Curt                <',[]),
   format('~n>                                                                     <',[]),
   format('~n> Type "help" to get more information about features                  <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: backgroundKnowledge.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(backgroundKnowledge,[backgroundKnowledge/2]).

:- use_module(comsemPredicates,[memberList/2,
				basicFormula/1,
				compose/3]).

:- use_module(lexicalKnowledge,[lexicalKnowledge/3]).

:- use_module(worldKnowledge,[worldKnowledge/3]).

:- use_module(situationalKnowledge,[situationalKnowledge/1]).


/*========================================================================
   Declare Dynamic Predicates
========================================================================*/

:- dynamic knowledge/1.


/*========================================================================
   Add Background Knowledge to Formula
========================================================================*/

backgroundKnowledge(Formula1,Formula2):-
   formula2symbols(Formula1,Symbols),
   backgroundKnowledge(Formula1,Symbols,Formula2).


/*========================================================================
   Add Background Knowledge until fixed point is reached
========================================================================*/

backgroundKnowledge(Formula1,Symbols1,Formula3):-
   computeBackgroundKnowledge(Symbols1,Formula2),
   formula2symbols(and(Formula1,Formula2),Symbols2),
   (
      sort(Symbols1,Sorted), %%% No new symbols, hence fixed point
      sort(Symbols2,Sorted), %%% is reached!
      !,
      Formula3=Formula2
   ;
      backgroundKnowledge(and(Formula1,Formula2),Symbols2,Formula3)
   ).


/*========================================================================
   Computing World Knowledge
========================================================================*/

computeBackgroundKnowledge(Symbols,Formula):-
   retractall(knowledge(_)),
   findall(_,(lexicalKnowledge(Symbol,Arity,F),
              memberList(symbol(Symbol,Arity),Symbols),
              assert(knowledge(F))),_),
   findall(_,(worldKnowledge(Symbol,Arity,F),
              memberList(symbol(Symbol,Arity),Symbols),
              assert(knowledge(F))),_),
   findall(_,(situationalKnowledge(F),
              assert(knowledge(F))),_),
   knowledge2formula(Formula).


/*========================================================================
   Put all selected knowledge in one big formula
========================================================================*/

knowledge2formula(F):-
   knowledge(F1),
   retract(knowledge(F1)),
   (
      knowledge(_), !,
      knowledge2formula(F2),
      F=and(F1,F2)
   ; 
      F=F1
   ).
   

/*========================================================================
   Derive all Symbols from a Formula
========================================================================*/

formula2symbols(F,S):-
   formula2symbols(F,[],S).

formula2symbols(X,S,S):-
   var(X), !.

formula2symbols(X,S,[symbol(X,0)|S]):-
   atom(X),
   \+ memberList(symbol(X,0),S).

formula2symbols(X,S,S):-
   atom(X),
   memberList(symbol(X,0),S).

formula2symbols(some(_,F),S1,S2):-
   formula2symbols(F,S1,S2).

formula2symbols(all(_,F),S1,S2):-
   formula2symbols(F,S1,S2).

formula2symbols(not(F),S1,S2):-
   formula2symbols(F,S1,S2).

formula2symbols(and(F1,F2),S1,S3):-
   formula2symbols(F1,S1,S2),
   formula2symbols(F2,S2,S3).

formula2symbols(or(F1,F2),S1,S3):-
   formula2symbols(F1,S1,S2),
   formula2symbols(F2,S2,S3).

formula2symbols(imp(F1,F2),S1,S3):-
   formula2symbols(F1,S1,S2),
   formula2symbols(F2,S2,S3).

formula2symbols(eq(X,Y),S1,S3):-
   formula2symbols(X,S1,S2),
   formula2symbols(Y,S2,S3).

formula2symbols(F,S1,[symbol(Symbol,1)|S2]):- 
   basicFormula(F),
   compose(F,Symbol,[Arg]),
   \+ memberList(symbol(Symbol,1),S1),
   formula2symbols(Arg,S1,S2).

formula2symbols(F,S1,S2):- 
   basicFormula(F),
   compose(F,Symbol,[Arg]),
   memberList(symbol(Symbol,1),S1),
   formula2symbols(Arg,S1,S2).

formula2symbols(F,S1,[symbol(Symbol,2)|S3]):- 
   basicFormula(F),
   compose(F,Symbol,[Arg1,Arg2]),
   \+ memberList(symbol(Symbol,2),S1),
   formula2symbols(Arg1,S1,S2),
   formula2symbols(Arg2,S2,S3).

formula2symbols(F,S1,S3):- 
   basicFormula(F),
   compose(F,Symbol,[Arg1,Arg2]),
   memberList(symbol(Symbol,2),S1),
   formula2symbols(Arg1,S1,S2),
   formula2symbols(Arg2,S2,S3).


/*************************************************************************

    File: betaConversion.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(betaConversion,[info/0,
                          infix/0,
                          prefix/0, 
                          betaConvertTestSuite/0,
			  betaConvert/2]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                compose/3]).

:- use_module(alphaConversion,[alphaConvert/2,
                               alphabeticVariants/2]).

:- use_module(betaConversionTestSuite,[expression/2]).


/*========================================================================
   Beta-Conversion (introducing stack)
========================================================================*/

betaConvert(X,Y):-
   betaConvert(X,Y,[]).


/*========================================================================
   Beta-Conversion (comment-in for tracing)
========================================================================*/

%betaConvert(X,_,S):-
%   nl, write('Expre: '), print(X),
%   nl, write('Stack: '), print(S), nl,
%   fail.


/*========================================================================
   Beta-Conversion (core stuff)
========================================================================*/

betaConvert(X,Y,[]):-
   var(X), !,
   Y=X.

betaConvert(Expression,Result,Stack):- 
   nonvar(Expression),
   Expression = app(Functor,Argument),
                                     %% To suppress alpha-conversion:
   alphaConvert(Functor,Converted),  %%   comment-out this line 
%   Functor=Converted,               %%   comment-in this line 

   betaConvert(Converted,Result,[Argument|Stack]), !.

betaConvert(Expression,Result,[X|Stack]):-
   nonvar(Expression),
   Expression = lam(X,Formula),
   betaConvert(Formula,Result,Stack), !.

betaConvert(Formula,Result,[]):-
   nonvar(Formula), !,
   compose(Formula,Functor,Formulas),
   betaConvertList(Formulas,ResultFormulas),
   compose(Result,Functor,ResultFormulas).

betaConvert(Exp,app(Exp,Y),[X]):-    %% Impossible to perform application.
   betaConvert(X,Y).


/*========================================================================
   Beta-Convert a list
========================================================================*/

betaConvertList([],[]).

betaConvertList([Formula|Others],[Result|ResultOthers]):-
   betaConvert(Formula,Result),
   betaConvertList(Others,ResultOthers).


/*========================================================================
   Prove all formulas from the test suite
========================================================================*/

betaConvertTestSuite:-
   format('~n>>>>> BETA CONVERSION ON TEST SUITE <<<<<~n',[]), 
   expression(Expression,Expected),
   format('~n~nExpression: ~p~nExpected: ~p',[Expression,Expected]),
   betaConvert(Expression,Converted,[]),
   format('~nConverted: ~p',[Converted]),
   compareResults(Expected,Converted,Result),
   format('~nResult: ~p',[Result]),
   fail.

betaConvertTestSuite.


/*========================================================================
   Compare Results of the Test Suite
========================================================================*/

compareResults(A,B,Result):-
    (
     alphabeticVariants(A,B),
     !,
     Result=ok
    ;
     Result=error
    ).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> betaConversion.pl, by Patrick Blackburn and Johan Bos               <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- betaConvert(F,C).         - beta-convert a formula               <',[]),
   format('~n> ?- betaConvertTestSuite.     - run the test suite                   <',[]),
   format('~n> ?- infix.                    - switches to infix display mode       <',[]),
   format('~n> ?- prefix.                   - switches to prefix display mode      <',[]),
   format('~n> ?- info.                     - shows this information               <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.


/*************************************************************************

    File: betaConversionTestSuite.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(betaConversionTestSuite,[expression/2]).


/*========================================================================
   Lambda-Expressions
========================================================================*/

expression(app(lam(P,app(P,mia)),lam(X,walk(X))),
	   walk(mia)).

expression(some(X,and(man(X),app(lam(P,some(X,and(woman(X),app(P,X)))),lam(Y,love(X,Y))))),
	   some(X,and(man(X),some(Y,and(woman(Y),love(X,Y)))))).

%%-----------------------------------------------------------------------
%% Simple reduction
%%   Ly. sleep(y) mia --> sleep(mia)
%%--------------------------------------

expression(app(lam(A,sleep(A)),mia),
           sleep(mia)).

%%-----------------------------------------------------------------------
%% Reduction to another function: 
%%   Ly.(Lx.like(x,y)) mia --> Lx.like(x,mia)  
%%-----------------------------------------------

expression(app(lam(A,lam(B,like(B,A))),mia),
           lam(C,like(C,mia))).

%%-----------------------------------------------------------------------
%% Reduction of inner expression leaving outer function: 
%%   Ly.(Lx.like(x,y) (vincent)) --> Ly.like(vincent,y)  
%%------------------------------------------------------

expression(lam(A,app(lam(B,like(B,A)),vincent)),
           lam(C,like(vincent,C))).

%%-------------------------------------------------------------------------
%% Reduction of inner expression leaving outer function, with var y shared.
%%   Ly.and((Lx.like(x,y) (vincent)),sleep(y)) --> 
%%                         Ly.and(like(vincent,y),sleep(y))
%%--------------------------------------------------------

expression(lam(A,and(app(lam(B,like(B,A)),vincent),sleep(A))),
           lam(C,and(like(vincent,C),sleep(C)))).

%%-----------------------------------------------------------------------
%% Reduction twice:  
%%   (Ly.(Lx.like(x,y)) mia) vincent) --> like(vincent,mia)  
%%------------------------------------------------------

expression(app(app(lam(A,lam(B,like(B,A))),mia),vincent),
           like(vincent,mia)).

%%-----------------------------------------------------------------------
%% Reductions in a nested position
%%    p((Lx.sleep(X))vincent) --> p(sleep(vincent))
%%---------------------------------------------

expression(p(app(lam(A,sleep(A)),vincent)),
           p(sleep(vincent))).

%%-----------------------------------------------------------------------
%% Reductions inside a variable predicate
%%    LP. P((Lx.sleep(x)) vincent) --> LP. P(sleep(vincent))
%%------------------------------------------------------

expression(lam(A,app(A,app(lam(B,sleep(B)),vincent))),
           lam(A,app(A,sleep(vincent)))).

%%-----------------------------------------------------------------------
%% No reductions possible
%%    LP. P(sleep(vincent)) --> LP. P(sleep(vincent))
%%------------------------------------------------------

expression(lam(A,app(A,sleep(vincent))),
           lam(A,app(A,sleep(vincent)))).

%%-----------------------------------------------------------------------
%% Nested reductions (apply to a function which must be applied again)
%%  LP. (P(vincent)) (Lx.sleep(x)) --> sleep(vincent)
%%-----------------------------------------------

expression(app(lam(A,app(A,vincent)),lam(B,sleep(B))),
           sleep(vincent)).

%%---------------------------------------------------------------------------
%%  LP. believe(mia,(P(vincent)) (Lx.sleep(x)) --> believe(mia,sleep(vincent))
%%---------------------------------------------------------------------------

expression(app(lam(A,believe(mia,app(A,vincent))),lam(B,sleep(B))),
           believe(mia,sleep(vincent))).

%%---------------------------------------------------------------------------
%% Copied functions
%% (LP. P*vincent and P*mia) Lx.sleep(x) --> sleep(vincent) and sleep(mia)
%%-----------------------------------------------------------------------

expression(app(lam(A,and(app(A,vincent),app(A,mia))),lam(B,sleep(B))),
           and(sleep(vincent),sleep(mia))).

%%------------------------------------------------------------------------
%%   (LP.(LQ.and(LR.R(P) prob), LR.R(Q) improb) (Lx.walk(x)) (Lx.talk(X)) 
%%      -> and(prob(walk(vincent)), improb(talk(mia)))   
%%------------------------------------------------------

expression(app(app(lam(A,lam(B,and(app(lam(C,app(C,app(A,vincent))),lam(D,probably(D))),app(lam(C,app(C,app(B,mia))),lam(D,improbably(D)))))),lam(E,walk(E))),lam(E,talk(E))),
           and(probably(walk(vincent)),improbably(talk(mia)))).


%%---------------------------------------------------------------------------
%% Double application.
%%
%% (Lu.(Lv . (LP.P(u,v) Ly.Lx.love(x,y)) mia) jules) --> love(jules,mia)
%%--------------------------------------------------------------------

expression(app(app(lam(A,lam(B,app(lam(C,app(app(C,A),B)),lam(D,lam(E,love(D,E)))))),jules),mia),
           love(jules,mia)).

%%---------------------------------------------------------------------------
%% Two functions with the same use of variable.
%% ((LP.LQ. Ex.(P*x and Q*x))) Ly.boxer(y)) Ly.sleep(y) --> 
%%                  Some(boxer(x) and sleep(x))
%%----------------------------------------------

expression(app(app(lam(A,lam(B,some(C,and(app(A,C),app(B,C))))),lam(D,boxer(D))),lam(D,sleep(D))),
           some(C,and(boxer(C),sleep(C)))).

%%------------------------------------------------------------------------
%% Test for correctly dealing with the same variable name occurring twice
%%    Lx(P(x)) (Ly.Lx.like(x,y)) --> P(Lx.Lz.like(z,x))
%% (loops without alpha-conversion)
%%-------------------------------------------------------

expression(app(lam(A,app(X,A)),lam(C,lam(A,like(A,C)))),
           app(X,lam(E,lam(F,like(F,E))))).

%%------------------------------------------------------------------------
%% Test for correctly performing alpha conversion
%%   LP.Lx(P(x)) (Ly.Lx.like(x,y)) --> Lx.Lz.like(z,x)
%%----------------------------------------------------

expression(app(lam(A,lam(B,app(A,B))),lam(C,lam(B,like(B,C)))),
           lam(D,lam(E,like(E,D)))).

%%---------------------------------------------------------------------------
%% Test for correctly performing alpha conversion
%% (Lx.(Ly. (LP.P(x,y) Ly.Lx.love(x,y)) mia) jules) --> love(jules,mia)
%%--------------------------------------------------------------------

expression(app(app(lam(A,lam(B,app(lam(C,app(app(C,A),B)),lam(B,lam(A,love(B,A)))))),jules),mia),
           love(jules,mia)).

%%---------------------------------------------------------------------------
%% Test for correctly performing alpha conversion
%% (Lx.(Ly. (LP.P(x,y) Ly.Lx.love(x,y)))) --> Lu.Lv. love(u,v)
%%--------------------------------------------------------------------

expression(lam(A,lam(B,app(lam(C,app(app(C,A),B)),lam(B,lam(A,love(B,A)))))),
           lam(D,lam(E,love(D,E)))).

%%---------------------------------------------------------------------------
%% Further alpha conversion testing
%% (LP. Lx. (Ex.P*x) and P*x) Ly.boxer(y) vincent
%%----------------------------------------------

expression(app(app(lam(A,lam(B,and(some(B,app(A,B)),app(A,B)))),lam(C,boxer(C))),vincent),
           and(some(B,boxer(B)),boxer(vincent))).

%%---------------------------------------------------------------------------
%% Tests for applications that can't be reduced
%%
%%---------------------------------------------------------------------------

expression(app(X,Y),
           app(X,Y)).

expression(app(app(X,Y),Z),
           app(app(X,Y),Z)).


/*************************************************************************

    File: callInference.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(callInference,[infix/0,
                         prefix/0,
                         callTP/3,
                         callMB/4,
                         callTPandMB/6,
                         mbTestSuite/0,
                         tpTestSuite/0,
                         tpmbTestSuite/0]).

:- use_module(fol2otter,[fol2otter/2,
                         fol2mace/2]).

:- use_module(fol2bliksem,[fol2bliksem/2]).

:- use_module(fol2tptp,[fol2tptp/2]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                appendLists/3,
     			        memberList/2,
                                selectFromList/3,
                                executeCommand/1,
				concatStrings/2]).

:- use_module(folTestSuite,[formula/2]).

:- [inferenceEngines].


/*========================================================================
   Initialise Theorem Provers
========================================================================*/

initTheoremProvers([],_).

initTheoremProvers([otter|L],Formula):- !,
   open('otter.in',write,Stream),
   fol2otter(not(Formula),Stream),
   close(Stream),
   initTheoremProvers(L,Formula).

initTheoremProvers([bliksem|L],Formula):- !,
   open('bliksem.in',write,Stream),
   fol2bliksem(not(Formula),Stream),
   close(Stream),
%   executeCommand('dos2unix bliksem.in'), %%% use for MS-DOS/Windows
   initTheoremProvers(L,Formula).

initTheoremProvers([_|L],Formula):-
   initTheoremProvers(L,Formula).


/*========================================================================
   Initialise Model Builders
========================================================================*/

initModelBuilders([],_).

initModelBuilders([mace|L],Formula):- !,
   open('mace.in',write,Stream),
   fol2mace(Formula,Stream),
   close(Stream),
   initModelBuilders(L,Formula).

initModelBuilders([paradox|L],Formula):- !,
   open('paradox.in',write,Stream),
   fol2tptp(not(Formula),Stream),
   close(Stream),
   initModelBuilders(L,Formula).

initModelBuilders([_|L],Formula):-
   initModelBuilders(L,Formula).


/*========================================================================
   Calls to Theorem Provers 
========================================================================*/

callTP(Problem,Proof,Engine):-
   executeCommand('chmod 700 interfaceTP.perl'),
   inferenceEngines(Engines),
   initTheoremProvers(Engines,Problem),
   concatStrings(['perl ./interfaceTP.perl '|Engines],Shell),        
   executeCommand(Shell),
   open('tp.out',read,Out),
   read(Out,Result),
   (
      Result=proof, !, 
      read(Out,engine(Engine)),
      Proof=proof
   ;
      Proof=unknown,
      Engine=unknown
   ),       
   close(Out).


/*========================================================================
   Calls to Model Builders
========================================================================*/

callMB(Problem,DomainSize,Model,Engine):-
   executeCommand('chmod 700 interfaceMB.perl'),
   number(DomainSize),
   inferenceEngines(Engines),
   initModelBuilders(Engines,Problem),
   concatStrings(['perl ./interfaceMB.perl ',DomainSize,' '|Engines],Shell),        
   executeCommand(Shell),
   open('mb.out',read,Out),
   read(Out,Result),
   (
      Result=interpretation(_,_),
      read(Out,engine(Engine)),
      mace2blackburnbos(Result,Model), !
   ;
      Result=paradox(_),
      read(Out,engine(Engine)),
      paradox2blackburnbos(Result,Model), !
   ;
      Model=unknown,
      Engine=unknown
   ),       
   close(Out).


/*========================================================================
   Calls to Theorem Provers and Model Builders
========================================================================*/

callTPandMB(TPProblem,MBProblem,DomainSize,Proof,Model,Engine):-
   executeCommand('chmod 700 interfaceTPandMB.perl'),
   number(DomainSize),
   inferenceEngines(Engines),
   initTheoremProvers(Engines,TPProblem),
   initModelBuilders(Engines,MBProblem),
   concatStrings(['perl ./interfaceTPandMB.perl ',DomainSize,' '|Engines],Shell),        
   executeCommand(Shell),
   open('tpmb.out',read,Out),
   read(Out,Result),
   (
      Result=proof, !, 
      read(Out,engine(Engine)),
      Proof=proof,
      Model=unknown
   ;
      Result=interpretation(_,_),
      read(Out,engine(Engine)),
      mace2blackburnbos(Result,Model), !,
      Proof=unknown
   ;
      Result=paradox(_),
      read(Out,engine(Engine)),
      paradox2blackburnbos(Result,Model), !,
      Proof=unknown
   ;
      Model=unknown,
      Proof=unknown,
      Engine=unknown
   ),       
   close(Out).



/*========================================================================
   Prove all formulas from the test suite (using Theorem Provers)
========================================================================*/

tpTestSuite:-
   format('~n~n>>>>> INFERENCE TEST SUITE <<<<<',[]),
   formula(Formula,Status),
   format('~nInput formula: ~p~nStatus: ~p',[Formula,Status]),
   callTP(Formula,Proof,Engine),
   ( 
      Proof=proof, 
      Result=theorem
   ;
      \+ Proof=proof, 
      Result=unknown
   ),
   format('~nInference engine ~p says: ~p~n',[Engine,Result]),
   fail.

tpTestSuite.


/*========================================================================
   Build models for formulas from the test suite (using Model Builders)
========================================================================*/

mbTestSuite:-
   format('~n~n>>>>> INFERENCE TEST SUITE <<<<<',[]),
   formula(Formula,Status),
   format('~nInput formula: ~p~nStatus: ~p',[Formula,Status]),
   callMB(Formula,30,Model,Engine),
   format('~nInference engine ~p says: ~p~n',[Engine,Model]),
   fail.

mbTestSuite.


/*========================================================================
   Prove or build models for all formulas from the test suite 
   (using Theorem Provers and model builders)
========================================================================*/

tpmbTestSuite:-
   format('~n~n>>>>> INFERENCE TEST SUITE <<<<<',[]),
   formula(Formula,Status),
   format('~nInput formula: ~p~nStatus: ~p',[Formula,Status]),
   callTPandMB(Formula,Formula,30,Proof,Model,Engine),
   ( 
      Proof=proof, 
      Result=theorem
   ;
      Proof=unknown,
      Model=model(_,_), 
      Result=Model
   ;
      Proof=unknown, 
      Model=unknown,
      Result=unknown
   ),
   format('~nInference engine ~p says: ~p~n',[Engine,Result]),
   fail.

tpmbTestSuite.


/*========================================================================
   Translate Paradox-type Model into Blackburn & Bos Models
========================================================================*/

paradox2blackburnbos(Paradox,model(D,F)):-
   Paradox = paradox(Terms), \+ Terms=[],
   paradox2d(Terms,[d1]-D),
   paradox2f(Terms,[]-F).

paradox2blackburnbos(Paradox,model([],[])):-
   Paradox = paradox([]).

paradox2blackburnbos(Paradox,unknown):-
   \+ Paradox = paradox(_).


/*========================================================================
   Translate Paradox Terms to Domain
========================================================================*/

paradox2d([],D-D).

paradox2d([_Constant=Entity|L],D1-D2):-
   \+ memberList(Entity,D1), !,
   paradox2d(L,[Entity|D1]-D2).

paradox2d([Symbol:1|L],D1-D2):-
   functor(Symbol,_Functor,1),
   arg(1,Symbol,Entity),
   \+ memberList(Entity,D1), !,
   paradox2d(L,[Entity|D1]-D2).

paradox2d([Symbol:1|L],D1-D2):-
   functor(Symbol,_Functor,2),
   arg(1,Symbol,Entity1),
   arg(2,Symbol,Entity2),
   (
      \+ memberList(Entity1,D1), !,
      (
         \+ memberList(Entity2,D2), !,
         paradox2d(L,[Entity1,Entity2|D1]-D2)
      ;
         paradox2d(L,[Entity1|D1]-D2) 
      )
   ;
      \+ memberList(Entity2,D2), 
      paradox2d(L,[Entity2|D1]-D2) 
   ), !.

paradox2d([_|L],D1-D2):-
   paradox2d(L,D1-D2).


/*========================================================================
   Translate Paradox Terms to Interpretation Function
========================================================================*/

paradox2f([],F-F).

paradox2f([Constant=Entity|L],D1-D2):-
   Term = f(0,Constant,Entity),
   \+ memberList(Term,D1), !,
   paradox2f(L,[Term|D1]-D2).

paradox2f([Symbol:1|L],D1-D2):-
   functor(Symbol,Functor,1), !,
   arg(1,Symbol,Arg),
   (
      selectFromList(f(1,Functor,E),D1,D3), !,
      paradox2f(L,[f(1,Functor,[Arg|E])|D3]-D2)
   ;
      paradox2f(L,[f(1,Functor,[Arg])|D1]-D2)
   ).

paradox2f([Symbol:0|L],D1-D2):-
   functor(Symbol,Functor,1), !,
   (
      memberList(f(1,Functor,_),D1), !,
      paradox2f(L,D1-D2)
   ;
      paradox2f(L,[f(1,Functor,[])|D1]-D2)
   ).

paradox2f([Symbol:1|L],D1-D2):-
   functor(Symbol,Functor,2), !,
   arg(1,Symbol,Arg1),
   arg(2,Symbol,Arg2),
   (
      selectFromList(f(2,Functor,E),D1,D3), !,
      paradox2f(L,[f(2,Functor,[(Arg1,Arg2)|E])|D3]-D2)
   ;
      paradox2f(L,[f(2,Functor,[(Arg1,Arg2)])|D1]-D2)
   ).

paradox2f([Symbol:0|L],D1-D2):-
   functor(Symbol,Functor,2), !,
   (
      memberList(f(2,Functor,_),D1), !,
      paradox2f(L,D1-D2)
   ;
      paradox2f(L,[f(2,Functor,[])|D1]-D2)
   ).

paradox2f([_|L],D1-D2):-
   paradox2f(L,D1-D2).


/*========================================================================
   Translate Mace-type Model into Blackburn & Bos Models
========================================================================*/

mace2blackburnbos(Mace,model(D,F)):-
   Mace = interpretation(Size,Terms),
   mace2d(1,Size,D),
   mace2f(Terms,D,F).

mace2blackburnbos(Mace,unknown):-
   \+ Mace = interpretation(_Size,_Terms).


/*========================================================================
   Translate Mace Model to Domain
========================================================================*/

mace2d(N,N,[V]):-
	name(N,Codes),
	name(V,[100|Codes]).

mace2d(I,N,[V|D]):-
	I < N,
	name(I,Codes),
	name(V,[100|Codes]),
	J is I + 1,
	mace2d(J,N,D).


/*========================================================================
   Translate Mace Model to Interpretation Function
========================================================================*/

mace2f([],_,[]):- !.

mace2f([function(Skolem,_)|Terms],D,F):-
	\+ atom(Skolem), !,
	mace2f(Terms,D,F).

mace2f([function(Constant,[V])|Terms],D,[f(0,Constant,X)|F]):-
	atom(Constant), !,
	Index is V + 1,
	name(Index,Codes),
	name(X,[100|Codes]),
	mace2f(Terms,D,F).

mace2f([predicate(Relation,V)|Terms],D,[f(1,Functor,X)|F]):-
	Relation =.. [Functor,_], !,
	positiveValues(V,1,X),
	mace2f(Terms,D,F).

mace2f([predicate(Relation,V)|Terms],D,[f(2,Functor,X)|F]):-
	Relation =.. [Functor,_,_], !,
	length(D,Size),
	positivePairValues(V,Size,1,1,X),
	mace2f(Terms,D,F).

mace2f([_|Terms],D,F):-
	mace2f(Terms,D,F).


/*========================================================================
   Take positive values of one-place predicates
========================================================================*/

positiveValues([],_,[]).

positiveValues([1|Values],I1,[X|Rest]):-
	name(I1,Codes),
	name(X,[100|Codes]),
	I2 is I1 + 1,
	positiveValues(Values,I2,Rest).
		
positiveValues([0|Values],I1,Rest):-
	I2 is I1 + 1,
	positiveValues(Values,I2,Rest).
		

/*========================================================================
   Take positive values of two-place predicates
========================================================================*/

positivePairValues([],_,_,_,[]).

positivePairValues([1|Values],Size,I1,J1,[(X2,X1)|Rest]):-
	name(I1,Codes1),
	name(X1,[100|Codes1]),
	name(J1,Codes2),
	name(X2,[100|Codes2]),
	(
	    I1 < Size,
	    I2 is I1 + 1,
	    J2 is J1
	;   
	    I1 = Size,
	    I2 = 1,
	    J2 is J1 + 1
	),
	positivePairValues(Values,Size,I2,J2,Rest).

positivePairValues([0|Values],Size,I1,J1,Rest):-
	(
	    I1 < Size, 
	    I2 is I1 + 1,
	    J2 is J1
	;
	    I1 = Size,
	    I2 = 1,
	    J2 is J1 + 1
	),
	positivePairValues(Values,Size,I2,J2,Rest).


/*========================================================================
   Info
========================================================================*/

info:-
   inferenceEngines(Engines),
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n> callInference.pl, by Patrick Blackburn and Johan Bos       <',[]),
   format('~n>                                                            <',[]),
   format('~n> ?- callTP(Problem,Proof,Engine).                           <',[]),
   format('~n> ?- callMB(Problem,DomainSize,Model,Engine)                 <',[]),
   format('~n> ?- callTPandMB(TPProblem,MBProblem,Size,Proof,Model,Eng).  <',[]),
   format('~n> ?- mbTestSuite.                                            <',[]),
   format('~n> ?- tpTestSuite.                                            <',[]),
   format('~n> ?- tpmbTestSuite.                                          <',[]),
   format('~n> ?- infix.                                                  <',[]),
   format('~n> ?- prefix.                                                 <',[]),
   format('~n>                                                            <',[]),
   format('~n> Selected Inference Engines (inferenceEngines/1)            <',[]),
   format('~n> ~p',[Engines]),
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: cleverCurt.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(curt,[curt/0,infix/0,prefix/0]).

:- use_module(callInference,[callTPandMB/6]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
				printRepresentations/1]).

:- use_module(kellerStorage,[kellerStorage/2]).

:- use_module(curtPredicates,[curtHelp/0,
                              curtOutput/1,
                              updateReadings/1,
                              updateModels/1,
                              updateHistory/1,
                              clearHistory/0,
                              selectReadings/3]).


/*========================================================================
   Dynamic Predicates
========================================================================*/

:- dynamic history/1, readings/1, models/1.

history([]).
readings([]).
models([]).


/*========================================================================
   Start Curt
========================================================================*/

curt:- 
   curtTalk(run).


/*========================================================================
   Control
========================================================================*/

curtTalk(quit).

curtTalk(run):-
   readLine(Input),
   curtUpdate(Input,CurtsMoves,State), 
   curtOutput(CurtsMoves),
   curtTalk(State).


/*========================================================================
   Update Curt's Information State
========================================================================*/

curtUpdate([],[clarify],run):- !.

curtUpdate([bye],[bye],quit):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([new],[],run):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([help],[],run):- !,
   curtHelp.

curtUpdate([infix],[],run):- !,
   infix.

curtUpdate([prefix],[],run):- !,
   prefix.

curtUpdate([select,X],[],run):-
   number(X),
   readings(R1),
   selectReadings(X,R1,R2), !,
   updateReadings(R2),
   models(M1),
   selectReadings(X,M1,M2),
   updateModels(M2).

curtUpdate([readings],[],run):- !,
   readings(R),
   printRepresentations(R).

curtUpdate([models],[],run):- !,
   models(M),
   printRepresentations(M).

curtUpdate([history],[],run):- !,
   history(H),
   printRepresentations(H).

curtUpdate(Input,Moves,run):-
   kellerStorage(Input,Readings), !,
   updateHistory(Input),
   consistentReadings(Readings,[]-ConsReadings,[]-Models),
   (
      ConsReadings=[],
      Moves=[contradiction]
   ;  
      \+ ConsReadings=[],
      Moves=[accept],
      combine(ConsReadings,CombinedReadings), 
      updateReadings(CombinedReadings),
      updateModels(Models)
   ).

curtUpdate(_,[noparse],run).


/*========================================================================
   Combine New Utterances with History
========================================================================*/

combine(New,New):- 
   readings([]).

combine(Readings,Updated):-
   readings([Old|_]),
   findall(and(Old,New),memberList(New,Readings),Updated).


/*========================================================================
   Select Consistent Readings
========================================================================*/

consistentReadings([],C-C,M-M).

consistentReadings([New|Readings],C1-C2,M1-M2):-
   readings(Old),
   (
      consistent(Old,New,Model), !,
      consistentReadings(Readings,[New|C1]-C2,[Model|M1]-M2) 
   ;
      consistentReadings(Readings,C1-C2,M1-M2) 
   ).


/*========================================================================
   Consistency Checking calling Theorem Prover and Model Builder
========================================================================*/

consistent([Old|_],New,Model):-
   DomainSize=15,
   callTPandMB(not(and(Old,New)),and(Old,New),DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).

consistent([],New,Model):-
   DomainSize=15,
   callTPandMB(not(New),New,DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n> cleverCurt.pl, by Patrick Blackburn and Johan Bos          <',[]),
   format('~n>                                                            <',[]),
   format('~n> ?- curt.              - start a dialogue with Curt         <',[]),
   format('~n>                                                            <',[]),
   format('~n> Type "help" to get more information about features         <',[]),
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: cnf.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(cnf,[info/0,
               infix/0,
               prefix/0,
               nnf/2,
               cnf/2,
               cnfTestSuite/0]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                appendLists/3,
				removeDuplicates/2]).

:- use_module(cnfTestSuite,[formulaClause/2]).


/*========================================================================
   Main Predicate
========================================================================*/

cnf(Formula,SetCNF):-
   nnf(Formula,NNF),
   nnf2cnf([[NNF]],[],CNF),
   setCnf(CNF,SetCNF).


/*========================================================================
   Running the Test Suite
========================================================================*/

cnfTestSuite:- 
   formulaClause(Formula,Cnf),
   format('~nInput formula: ~p',[Formula]),
   format('~nKnown cnf: ~p',[Cnf]),
   cnf(Formula,CNF),
   format('~nComputed cnf: ~p~n',[CNF]),
   fail.

cnfTestSuite.


/*========================================================================
   Convert to Negated Normal Form
========================================================================*/

nnf(not(and(F1,F2)),or(N1,N2)):- 
   nnf(not(F1),N1), 
   nnf(not(F2),N2).
   
nnf(and(F1,F2),and(N1,N2)):- 
   nnf(F1,N1),
   nnf(F2,N2).
   
nnf(not(or(F1,F2)),and(N1,N2)):-
   nnf(not(F1),N1),
   nnf(not(F2),N2).
   
nnf(or(F1,F2),or(N1,N2)):-
   nnf(F1,N1),
   nnf(F2,N2).

nnf(not(imp(F1,F2)),and(N1,N2)):- 
   nnf(F1,N1),
   nnf(not(F2),N2).
   
nnf(imp(F1,F2),or(N1,N2)):- 
   nnf(not(F1),N1),
   nnf(F2,N2).
   
nnf(not(not(F1)),N1):-
   nnf(F1,N1).
   
nnf(F1,F1):-
   literal(F1).


/*========================================================================
   Literals
========================================================================*/

literal(not(F)):- atomic(F).
literal(F):- atomic(F).


/*========================================================================
   Convert From Negative Normal Form to Conjunctive Normal Form
========================================================================*/

nnf2cnf([],_,[]).

nnf2cnf([[]|Tcon],Lit,[Lit|NewTcon]):-
   !,
   nnf2cnf(Tcon,[],NewTcon).

nnf2cnf([[and(F1,F2)|Tdis]|Tcon],Lits,Output):-
   !,
   appendLists(Tdis,Lits,Full),
   nnf2cnf([[F1|Full],[F2|Full]|Tcon],[],Output).

nnf2cnf([[or(F1,F2)|Tdis]|Tcon],Lits,Output):-
   !,
   nnf2cnf([[F1,F2|Tdis]|Tcon],Lits,Output).

nnf2cnf([[Lit|Tdis]|Tcon],Lits,Output):-
   nnf2cnf([Tdis|Tcon],[Lit|Lits],Output).


/*========================================================================
   Remove Duplicates
========================================================================*/

setCnf(Cnf1,Cnf2):-
   setCnf(Cnf1,[],Cnf2).

setCnf([],Cnf1,Cnf2):-
   removeDuplicates(Cnf1,Cnf2).

setCnf([X1|L1],L2,L3):-
   removeDuplicates(X1,X2),
   setCnf(L1,[X2|L2],L3).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> cnf.pl, by Patrick Blackburn and Johan Bos                          <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- cnf(Formula,CNF).  - converts formula in conjunctive normal form <',[]),
   format('~n> ?- nnf(Formula,CNF).  - converts formula in negative normal form    <',[]),
   format('~n> ?- cnfTestSuite.      - runs the test suite for CNF conversion      <',[]),
   format('~n> ?- infix.             - switches to infix display mode              <',[]),
   format('~n> ?- prefix.            - switches to prefix display mode             <',[]),
   format('~n> ?- info.              - show this information                       <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: cnfFOL.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(cnfFOL,[info/0,
                  prefix/0,
                  infix/0,
                  nnf/2,
                  cnf/2,
                  cnfTestSuite/0]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                appendLists/3,
                                basicFormula/1,
				newFunctionCounter/1,
                                substitute/4,
                                compose/3,
				removeDuplicates/2]).

:- use_module(cnfTestSuite,[formulaClause/2]).


/*========================================================================
   Main Predicate
========================================================================*/

cnf(Formula,SetCNF):-
   nnf(Formula,NNF),
   skolemise(NNF,Skolemised,[]),
   cnf([[Skolemised]],[],CNF),
   setCnf(CNF,SetCNF).


/*========================================================================
   Running the Test Suite
========================================================================*/

cnfTestSuite:- 
   formulaClause(Formula,Cnf),
   format('~nInput formula: ~p',[Formula]),
   format('~nKnown cnf: ~p',[Cnf]),
   cnf(Formula,CNF),
   format('~nComputed cnf: ~p~n',[CNF]),
   fail.

cnfTestSuite.


/*========================================================================
   Convert to Negated Normal Form
========================================================================*/

nnf(not(all(X,F)),some(X,N)):-
   nnf(not(F),N).

nnf(all(X,F),all(X,N)):-
   nnf(F,N).

nnf(not(some(X,F)),all(X,N)):-
   nnf(not(F),N).

nnf(some(X,F),some(X,N)):-
   nnf(F,N).

nnf(not(and(F1,F2)),or(N1,N2)):- 
   nnf(not(F1),N1), 
   nnf(not(F2),N2).
   
nnf(and(F1,F2),and(N1,N2)):- 
   nnf(F1,N1),
   nnf(F2,N2).
   
nnf(not(or(F1,F2)),and(N1,N2)):-
   nnf(not(F1),N1),
   nnf(not(F2),N2).
   
nnf(or(F1,F2),or(N1,N2)):-
   nnf(F1,N1),
   nnf(F2,N2).

nnf(not(imp(F1,F2)),and(N1,N2)):- 
   nnf(F1,N1),
   nnf(not(F2),N2).
   
nnf(imp(F1,F2),or(N1,N2)):- 
   nnf(not(F1),N1),
   nnf(F2,N2).
   
nnf(not(not(F1)),N1):-
   nnf(F1,N1).
   
nnf(F1,F1):-
   literal(F1).


/*========================================================================
   Literals
========================================================================*/

literal(not(F)):- basicFormula(F).
literal(F):- basicFormula(F).


/*========================================================================
   Convert From Negative Normal Form to Conjunctive Normal Form
========================================================================*/

cnf([],_,[]).

cnf([[]|Tcon],Lit,[Lit|NewTcon]):-
   !,
   cnf(Tcon,[],NewTcon).

cnf([[and(F1,F2)|Tdis]|Tcon],Lits,Output):-
   !,
   appendLists(Tdis,Lits,Full),
   cnf([[F1|Full],[F2|Full]|Tcon],[],Output).

cnf([[or(F1,F2)|Tdis]|Tcon],Lits,Output):-
   !,
   cnf([[F1,F2|Tdis]|Tcon],Lits,Output).

cnf([[Lit|Tdis]|Tcon],Lits,Output):-
   cnf([Tdis|Tcon],[Lit|Lits],Output).


/*========================================================================
   Remove Duplicates and Sort
========================================================================*/

setCnf(Cnf1,Cnf2):-
   setCnf(Cnf1,[],Cnf2).

setCnf([],Cnf1,Cnf2):-
   removeDuplicates(Cnf1,Cnf2).

setCnf([X1|L1],L2,L3):-
   removeDuplicates(X1,X2),
   sort(X2,X3),
   setCnf(L1,[X3|L2],L3).


/*========================================================================
   Skolemise
========================================================================*/

skolemise(all(X,F),N,Vars):- 
   skolemise(F,N,[X|Vars]).

skolemise(some(X,F1),N,Vars):-
   skolemFunction(Vars,SkolemTerm),
   substitute(SkolemTerm,X,F1,F2),
   skolemise(F2,N,Vars).

skolemise(and(F1,F2),and(N1,N2),Vars):-
   skolemise(F1,N1,Vars),
   skolemise(F2,N2,Vars).

skolemise(or(F1,F2),or(N1,N2),Vars):-
   skolemise(F1,N1,Vars),
   skolemise(F2,N2,Vars).

skolemise(F,F,_):-
   literal(F).


/*========================================================================
   VarList is a list of free variables, and SkolemTerm is a previously 
   unused Skolem function symbol fun(N) applied to those free variables.
========================================================================*/

skolemFunction(VarList,SkolemTerm):-
   newFunctionCounter(N),
   compose(SkolemTerm,fun,[N|VarList]).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> cnfFOL.pl, by Patrick Blackburn and Johan Bos                       <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- cnf(Formula,CNF).  - converts formula in conjunctive normal form <',[]),
   format('~n> ?- nnf(Formula,CNF).  - converts formula in negative normal form    <',[]),
   format('~n> ?- cnfTestSuite.      - runs the test suite for CNF conversion      <',[]),
   format('~n> ?- infix.             - switches to infix display mode              <',[]),
   format('~n> ?- prefix.            - switches to prefix display mode             <',[]),
   format('~n> ?- info.              - show this information                       <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: cnfTestSuite.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(cnfTestSuite,[formulaClause/2]).


/*========================================================================
   Formulas and known cnf forms for them.
========================================================================*/

formulaClause(imp(p,q),[[not(p),q]]).

formulaClause(imp(and(p,imp(q,r)),s),[[s,not(p),q],[s,not(p),not(r)]]).

formulaClause(or(not(or(not(p),q)),or(not(r),p)),[[p,not(r)],[not(q),not(r),p]]).

formulaClause(imp(imp(not(p),q),imp(not(r),s)),[[not(p),r,s],[not(q),r,s]]).


/*************************************************************************

    File: comsemPredicates.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(comsemPredicates,
          [appendLists/3,
	   basicFormula/1,
           compose/3,
	   concatStrings/2,
	   executeCommand/1,
           infix/0,
           memberList/2,
	   newFunctionCounter/1,
           prefix/0,
           printRepresentations/1,
	   proveOnce/1,
	   removeFirst/3,
	   removeDuplicates/2,
           reverseList/2,
	   selectFromList/3,
	   simpleTerms/1,
           substitute/4,
	   unionSets/3,
	   variablesInTerm/2]).


/*========================================================================
   Appending two lists
========================================================================*/

appendLists([],List,List).
appendLists([X|Tail1],List,[X|Tail2]):- 
   appendLists(Tail1,List,Tail2).


/*========================================================================
   List membership
========================================================================*/

memberList(X,[X|_]).
memberList(X,[_|Tail]):- 
   memberList(X,Tail).

 
/*========================================================================
   Reversing Items in a List
========================================================================*/
 
reverseList(A,B):-
   reverseList(A,[],B).
 
reverseList([],L,L).
 
reverseList([X|L1],L2,L3):-
   reverseList(L1,[X|L2],L3).


/*========================================================================
   Selecting (i.e. removing) a member of a list
========================================================================*/

selectFromList(X,[X|L],L).
selectFromList(X,[Y|L1],[Y|L2]):-
   selectFromList(X,L1,L2).


/*========================================================================
   Removing first member of a list
========================================================================*/

removeFirst(X,[X|Tail],Tail) :- !.
removeFirst(X,[Head|Tail],[Head|NewTail]):-
   removeFirst(X,Tail,NewTail).


/*========================================================================
   Remove Duplicates
========================================================================*/

removeDuplicates([],[]).

removeDuplicates([X|L],Pruned):-
	memberList(Y,L), X==Y, !,
	removeDuplicates(L,Pruned).

removeDuplicates([X|L],[X|Pruned]):-
	removeDuplicates(L,Pruned).


/*========================================================================
   Union of two sets (disallowing unification of list elements)
========================================================================*/

unionSets([],L,L).

unionSets([X|L1],L2,L3):-
   memberList(Y,L2), 
   X==Y, !,
   unionSets(L1,L2,L3).

unionSets([X|L1],L2,[X|L3]):-
   unionSets(L1,L2,L3).


/*========================================================================
   Simple Terms
========================================================================*/

simpleTerms([]).

simpleTerms([X|Rest]):-
   simpleTerm(X),
   simpleTerms(Rest).

simpleTerm(T):-
   (
    var(T)
   ;   
    atomic(T)
   ;
    nonvar(T),
    functor(T,'$VAR',1) 
   ;
    nonvar(T),
    functor(T,fun,_)
   ).


/*========================================================================
   Compose predicate argument structure
========================================================================*/

compose(Term,Symbol,ArgList):-
    Term =.. [Symbol|ArgList].


/*========================================================================
   Basic Formula Syntax
========================================================================*/

basicFormula(F):-
   var(F), !, fail.

basicFormula(F):-
   compose(F,Symbol,Args),
   \+ memberList(Symbol,[not,and,imp,app,or,some,all,lam,eq]),
   simpleTerms(Args).
		

/*========================================================================
   Collect all occurrences of variables in Term to a difference list
========================================================================*/

variablesInTerm(Term,Var1-Var2):-
   compose(Term,_,Args),
   countVar(Args,Var1-Var2).

countVar([],Var-Var).
countVar([X|Rest],Var1-Var2):-
   var(X),!,
   countVar(Rest,[X|Var1]-Var2).
countVar([X|Rest],Var1-Var3):-
   variablesInTerm(X,Var1-Var2),
   countVar(Rest,Var2-Var3).


/*========================================================================
   Substitution Predicates
========================================================================*/

substitute(Term,Var,Exp,Result):- 
   Exp==Var, !, Result=Term.

substitute(_Term,_Var,Exp,Result):- 
   \+ compound(Exp), !, Result=Exp.

substitute(Term,Var,Formula,Result):-
   compose(Formula,Functor,[Exp,F]),
   memberList(Functor,[lam,all,some]), !, 
   (
    Exp==Var, !, 
    Result=Formula
   ; 
    substitute(Term,Var,F,R),
    compose(Result,Functor,[Exp,R])
   ).

substitute(Term,Var,Formula,Result):-
   compose(Formula,Functor,ArgList),
   substituteList(Term,Var,ArgList,ResultList),
   compose(Result,Functor,ResultList).

substituteList(_Term,_Var,[],[]).
substituteList(Term,Var,[Exp|Others],[Result|ResultOthers]):-
   substitute(Term,Var,Exp,Result),
   substituteList(Term,Var,Others,ResultOthers).


/*========================================================================
   Skolem Function Counter
========================================================================*/

:- dynamic(functionCounter/1).

functionCounter(1).

newFunctionCounter(N):-
   functionCounter(N), M is N+1,
   retract(functionCounter(N)),
   asserta(functionCounter(M)).


/*========================================================================
   Printing a set of representations
========================================================================*/

printRepresentations(Readings):-
   printRep(Readings,0).

printRep([],_):- nl.
printRep([Reading|OtherReadings],M):-
   N is M + 1, nl, write(N), tab(1), 
   \+ \+ (numbervars(Reading,0,_), print(Reading)),
   printRep(OtherReadings,N).


/*========================================================================
   Concatenate Strings
========================================================================*/

concatStrings(L,S):-
   concatStrings(L,[],S).

concatStrings([],Codes,String):- 
   name(String,Codes).

concatStrings([X|L],Codes1,String):-
   name(X,Codes2),
   appendLists(Codes1,Codes2,Codes3),
   concatStrings(L,Codes3,String).
   

/*========================================================================
   Prove a goal only once
========================================================================*/

proveOnce(Goal):- call(Goal), !.


/*========================================================================
   Prolog Dialect Detection
========================================================================*/

prologDialect(Dialect):-
   (
    predicate_property(version,Property),
    Property=built_in, !,
    Dialect=sicstus            % Probably Sicstus Prolog
   ;
    predicate_property(shell(_,_),Property),
    Property=interpreted, !,
    Dialect=swi                % Probably SWI Prolog
   ;
    Dialect=unknown
   ).


/*========================================================================
   Execute Operating System Command
========================================================================*/

executeCommand(A):-
   shell(A,_).
   

/*========================================================================
   Load Sicstus library if required
========================================================================*/

load_shell:-
   prologDialect(sicstus), !,
   use_module(library(system),[shell/2]).

load_shell.


/*========================================================================
   Load Shell
========================================================================*/

:- load_shell.


/*========================================================================
   Prefix/Infix Switch
========================================================================*/
  
:- dynamic bbmode/1.
 
bbmode(prefix).
 
infix:- retractall(bbmode(_)), assert(bbmode(infix)).
prefix:- retractall(bbmode(_)), assert(bbmode(prefix)).

 
/*========================================================================
   Portray B&B Syntax
========================================================================*/

%user:portray(E):- bbmode(prefix), !, write_term(E,[numbervars(true)]).

user:portray(not(F)):- bbmode(infix), !, write('~ '), print(F).
user:portray(and(F1,F2)):- bbmode(infix), !, write('('), print(F1), write(' & '), print(F2), write(')').
user:portray(imp(F1,F2)):- bbmode(infix), !, write('('), print(F1), write(' > '), print(F2), write(')').
user:portray(app(F1,F2)):- bbmode(infix), !, write('('), print(F1), write(' @ '), print(F2), write(')').
user:portray(or(F1,F2)):- bbmode(infix), !, write('('), print(F1), write(' v '), print(F2), write(')').
user:portray(some(X,F)):- bbmode(infix), !, write('some '), write_term(X,[numbervars(true)]), tab(1), print(F).
user:portray(all(X,F)):- bbmode(infix), !, write('all '), write_term(X,[numbervars(true)]), tab(1), print(F).
user:portray(lam(X,F)):- bbmode(infix), !, write('lam '), write_term(X,[numbervars(true)]), tab(1), print(F).
user:portray(eq(X,Y)):- bbmode(infix), !, write_term(X,[numbervars(true)]), write(' = '), write_term(Y,[numbervars(true)]).
user:portray(que(X,R,B)):- bbmode(infix), !, write('?'), write_term(X,[numbervars(true)]), write('['), print(R), write(','), print(B), write(']').
user:portray(model(A,B)):- printModel(model(A,B)).
user:portray(E):- write_term(E,[numbervars(true)]).


/*========================================================================
   Print Model
========================================================================*/

printModel(model(Dom,Ext)):-
   write('D='),write(Dom),nl,
   printExtensions(Ext).

printExtensions([]).

printExtensions([X|L]):-
   tab(2), write(X), nl,
   printExtensions(L).




/*************************************************************************

    File: cooperStorage.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(cooperStorage,[info/0,
                         infix/0,
                         prefix/0,             
                         cooperStorage/0,
			 cooperStorage/2,
			 cooperStorageTestSuite/0]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[memberList/2,
				appendLists/3,
				selectFromList/3,
				compose/3,
                                infix/0,
                                prefix/0,
				printRepresentations/1]).

:- use_module(alphaConversion,[alphabeticVariants/2]).

:- use_module(betaConversion,[betaConvert/2]).

:- use_module(sentenceTestSuite,[sentence/2]).

:- [englishGrammar].

:- [englishLexicon].

:- [semLexStorage].

:- [semRulesCooper].


/*========================================================================
   Driver Predicates
========================================================================*/

cooperStorage:-
   readLine(Sentence),
   setof(Sem,t([sem:Sem],Sentence,[]),Sems1),
   filterAlphabeticVariants(Sems1,Sems2),
   printRepresentations(Sems2).

cooperStorage(Sentence,Sems2):-
   setof(Sem,t([sem:Sem],Sentence,[]),Sems1),
   filterAlphabeticVariants(Sems1,Sems2).


/*========================================================================
   Test Suite Predicates
========================================================================*/

cooperStorageTestSuite:-
   nl, write('>>>>> COOPER STORAGE ON SENTENCE TEST SUITE <<<<< '), nl,
   sentence(Sentence,Readings),
   format('~nSentence: ~p (~p readings)',[Sentence,Readings]),
   cooperStorage(Sentence,Sems),
   printRepresentations(Sems),
   fail.

cooperStorageTestSuite.


/*========================================================================
   Filter Alphabetic Variants
========================================================================*/

filterAlphabeticVariants(L1,L2):-
   selectFromList(X,L1,L3),
   memberList(Y,L3),
   alphabeticVariants(X,Y), !,
   filterAlphabeticVariants(L3,L2).

filterAlphabeticVariants(L,L).


/*========================================================================
   Quantifier Retrieval
========================================================================*/

sRetrieval([S],S).

sRetrieval([Sem|Store],S):-
   selectFromList(bo(Q,X),Store,NewStore),
   sRetrieval([app(Q,lam(X,Sem))|NewStore],S).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> cooperStorage.pl, by Patrick Blackburn and Johan Bos                <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- cooperStorage.            - parse a typed-in sentence            <',[]),
   format('~n> ?- cooperStorage(S,F).       - parse a sentence and return formulas <',[]),
   format('~n> ?- cooperStorageTestSuite.   - run the test suite                   <',[]),
   format('~n> ?- infix.                    - switches to infix display mode       <',[]),
   format('~n> ?- prefix.                   - switches to prefix display mode      <',[]),
   format('~n> ?- info.                     - shows this information               <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.


/*************************************************************************

    File: curtPredicates.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(curtPredicates,[curtHelp/0,
                          curtOutput/1,
                          updateReadings/1,
                          updateModels/1,
                          updateHistory/1,
                          clearHistory/0,
                          list2string/2,
                          selectReadings/3]).

:- use_module(comsemPredicates,[appendLists/3]).


/*========================================================================
   Curt Help
========================================================================*/

curtHelp:-
   nl, write('readings: prints current readings'),
   nl, write('select N: select a reading (N should be a number)'),
   nl, write('new: starts a new discourse'),
   nl, write('history: shows history of discourse'),
   nl, write('models: prints current models'),
   nl, write('summary: eliminate equivalent readings'),
   nl, write('knowledge: calculate and show background knowledge'),
   nl, write('infix: display formulas in infix notation'),
   nl, write('prefix: display formulas in prefix notation'),
   nl, write('bye: no more talking'),
   nl.


/*========================================================================
   Curt's output
========================================================================*/

curtOutput([]).

curtOutput([Move|Moves]):-
   realiseMove(Move,Output),
   format('~nCurt: ~p~n',[Output]),
   curtOutput(Moves).


/*========================================================================
   Curt's Moves
========================================================================*/

realiseMove(clarify,'Want to tell me something?').
realiseMove(bye,'Goodbye!').
realiseMove(accept,'OK.').
realiseMove(noparse,'What?').
realiseMove(contradiction,'No! I do not believe that!').
realiseMove(obvious,'Well, that is obvious!').
realiseMove(unknown_answer,'I have no idea.').
realiseMove(sensible_question,'This question makes sense!').
realiseMove(answer(String),String).


/*========================================================================
   Select Readings
========================================================================*/

selectReadings(X,R1,R2):-
   selectReadings(1,X,R1,R2).

selectReadings(X,X,[R|_],[R]).

selectReadings(X,Y,[_|L],R):-
   X < Y,
   Z is X + 1,
   selectReadings(Z,Y,L,R).
 

/*========================================================================
   Update History
========================================================================*/

updateHistory(Input):-
   retract(curt:history(His1)),
   appendLists(His1,[Input],His2),
   assert(curt:history(His2)).


/*========================================================================
   Clear History
========================================================================*/

clearHistory:-
   retract(curt:history(_)),
   assert(curt:history([])).


/*========================================================================
   Update Readings
========================================================================*/

updateReadings(R):-
   retract(curt:readings(_)),
   assert(curt:readings(R)).


/*========================================================================
   Update Models
========================================================================*/

updateModels(R):-
   retract(curt:models(_)),
   assert(curt:models(R)).


/*========================================================================
    Covert a list of words to a string
========================================================================*/

list2string([Word],Word).

list2string([Word|L],String2):-
   list2string(L,String1),
   name(Word,Codes1),
   name(String1,Codes2),
   appendLists(Codes1,[32|Codes2],Codes3),
   name(String2,Codes3).


/*************************************************************************

    File: elimEquivReadings.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(elimEquivReadings,[elimEquivReadings/2]).

:- use_module(callInference,[callTP/3]).

:- use_module(comsemPredicates,[memberList/2,
				selectFromList/3,
				printRepresentations/1]).


/*========================================================================
   Eliminate Equivalent Readings
========================================================================*/

elimEquivReadings([],[]).

elimEquivReadings([Reading],[Reading]).

elimEquivReadings(Readings,Unique):-
   numberReadings(Readings,0,N,Numbered),
   format('~nMessage (eliminating equivalent readings): there are ~p readings:',[N]),
   printRepresentations(Readings),
   elimEquivReadings(Numbered,[],Unique).


/*========================================================================
   Number the readings
========================================================================*/

numberReadings([],N,N,[]):-
   N > 1.

numberReadings([X|L1],N1,N3,[n(N2,X)|L2]):-
   N2 is N1 + 1,
   numberReadings(L1,N2,N3,L2).


/*========================================================================
   Check equivalence by calling a theorem prover
========================================================================*/

elimEquivReadings(Numbered,Diff,Unique):-
   selectFromList(n(N1,R1),Numbered,Readings),
   memberList(n(N2,R2),Readings),
   \+ memberList(diff(N1,N2),Diff), !,
   Formula=and(imp(R1,R2),imp(R2,R1)),
   callTP(Formula,Result,Engine),
   (
      Result=proof, !,
      format('Readings ~p and ~p are equivalent (~p).~n',[N1,N2,Engine]),
      elimEquivReadings(Readings,Diff,Unique)
   ;
      format('Readings ~p and ~p are probably not equivalent.~n',[N1,N2]),
      elimEquivReadings([n(N1,R1)|Readings],[diff(N1,N2),diff(N2,N1)|Diff],Unique)
   ).

elimEquivReadings(Numbered,_,Unique):-
   findall(Reading,memberList(n(_,Reading),Numbered),Unique).




/*************************************************************************

    File: englishGrammar.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Texts
========================================================================*/

t([sem:T])--> 
   s([coord:no,sem:S]),
   {combine(t:T,[s:S])}.

t([sem:T])--> 
   s([coord:yes,sem:S]),
   {combine(t:T,[s:S])}.

t([sem:T])--> 
   q([sem:Q]),
   {combine(t:T,[q:Q])}.


/*========================================================================
   Sentences
========================================================================*/

s([coord:no,sem:Sem])--> 
   np([coord:_,num:Num,gap:[],sem:NP]), 
   vp([coord:_,inf:fin,num:Num,gap:[],sem:VP]), 
   {combine(s:Sem,[np:NP,vp:VP])}.

s([coord:yes,sem:Sem])--> 
   s([coord:ant,sem:S1]), 
   s([coord:con,sem:S2]), 
   {combine(s:Sem,[s:S1,s:S2])}.

s([coord:yes,sem:Sem])--> 
   s([coord:either,sem:S1]), 
   s([coord:or,sem:S2]), 
   {combine(s:Sem,[s:S1,s:S2])}.

s([coord:ant,sem:Sem])--> 
   [if], 
   s([coord:no,sem:S]),
   {combine(s:Sem,[if:S])}.

s([coord:either,sem:Sem])--> 
   [either], 
   s([coord:no,sem:S]),
   {combine(s:Sem,[either:S])}.

s([coord:con,sem:Sem])--> 
   [then], 
   s([coord:no,sem:S]),
   {combine(s:Sem,[then:S])}.

s([coord:con,sem:Sem])-->
   s([coord:no,sem:S]),
   {combine(s:Sem,[then:S])}.

s([coord:or,sem:Sem])-->
   [or], 
   s([coord:no,sem:S]),
   {combine(s:Sem,[or:S])}.

sinv([gap:G,sem:S])-->
   av([inf:fin,num:Num,sem:Sem]),
   np([coord:_,num:Num,gap:[],sem:NP]),
   vp([coord:_,inf:inf,num:Num,gap:G,sem:VP]), 
   {combine(sinv:S,[av:Sem,np:NP,vp:VP])}.


/*========================================================================
   Questions
========================================================================*/

q([sem:Sem])--> 
   whnp([num:Num,sem:NP]), 
   vp([coord:_,inf:fin,num:Num,gap:[],sem:VP]), 
   {combine(q:Sem,[whnp:NP,vp:VP])}.

q([sem:Sem])--> 
   whnp([num:_,sem:NP]), 
   sinv([gap:[np:NP],sem:S]),
   {combine(q:Sem,[sinv:S])}.


/*========================================================================
   Noun Phrases
========================================================================*/

np([coord:no,num:sg,gap:[np:NP],sem:NP])--> [].

np([coord:yes,num:pl,gap:[],sem:NP])--> 
   np([coord:no,num:sg,gap:[],sem:NP1]), 
   coord([type:conj,sem:C]), 
   np([coord:_,num:_,gap:[],sem:NP2]), 
   {combine(np:NP,[np:NP1,coord:C,np:NP2])}.

np([coord:yes,num:sg,gap:[],sem:NP])--> 
   np([coord:no,num:sg,gap:[],sem:NP1]), 
   coord([type:disj,sem:C]), 
   np([coord:_,num:sg,gap:[],sem:NP2]), 
   {combine(np:NP,[np:NP1,coord:C,np:NP2])}.

np([coord:no,num:sg,gap:[],sem:NP])--> 
   det([mood:decl,type:_,sem:Det]), 
   n([coord:_,sem:N]), 
   {combine(np:NP,[det:Det,n:N])}.

np([coord:no,num:sg,gap:[],sem:NP])--> 
   pn([sem:PN]), 
   {combine(np:NP,[pn:PN])}.

np([coord:no,num:sg,gap:[],sem:NP])--> 
   qnp([mood:decl,sem:QNP]), 
   {combine(np:NP,[qnp:QNP])}.


/*========================================================================
   WH Noun Phrases
========================================================================*/

whnp([num:sg,sem:NP])--> 
   qnp([mood:int,sem:QNP]), 
   {combine(whnp:NP,[qnp:QNP])}.

whnp([num:sg,sem:NP])--> 
   det([mood:int,type:_,sem:Det]), 
   n([coord:_,sem:N]), 
   {combine(whnp:NP,[det:Det,n:N])}.


/*========================================================================
   Nouns
========================================================================*/

n([coord:yes,sem:N])--> 
   n([coord:no,sem:N1]), 
   coord([type:_,sem:C]),  
   n([coord:_,sem:N2]),
   {combine(n:N,[n:N1,coord:C,n:N2])}.

n([coord:C,sem:Sem])--> 
   adj([sem:A]), 
   n([coord:C,sem:N]), 
   {combine(n:Sem,[adj:A,n:N])}.

n([coord:no,sem:N])--> 
   noun([sem:Noun]),
   {combine(n:N,[noun:Noun])}.

n([coord:no,sem:Sem])--> 
   noun([sem:N]), 
   nmod([sem:PP]),
   {combine(n:Sem,[noun:N,nmod:PP])}. 

nmod([sem:N])--> 
   pp([sem:PP]),
   {combine(nmod:N,[pp:PP])}.

nmod([sem:N])--> 
   rc([sem:RC]),
   {combine(nmod:N,[rc:RC])}.

nmod([sem:Sem])--> 
   pp([sem:PP]), 
   nmod([sem:NMod]),
   {combine(nmod:Sem,[pp:PP,nmod:NMod])}.


/*========================================================================
   Verb Phrases
========================================================================*/

vp([coord:yes,inf:Inf,num:Num,gap:[],sem:VP])--> 
   vp([coord:no,inf:Inf,num:Num,gap:[],sem:VP1]), 
   coord([type:_,sem:C]), 
   vp([coord:_,inf:Inf,num:Num,gap:[],sem:VP2]),
   {combine(vp:VP,[vp:VP1,coord:C,vp:VP2])}.

vp([coord:no,inf:Inf,num:Num,gap:[],sem:VP])--> 
   av([inf:Inf,num:Num,sem:Mod]), 
   vp([coord:_,inf:inf,num:Num,gap:[],sem:V2]), 
   {combine(vp:VP,[av:Mod,vp:V2])}.

vp([coord:no,inf:Inf,num:Num,gap:[],sem:VP])--> 
   cop([inf:Inf,num:Num,sem:Cop]), 
   np([coord:_,num:_,gap:[],sem:NP]), 
   {combine(vp:VP,[cop:Cop,np:NP])}.

vp([coord:no,inf:Inf,num:Num,gap:[],sem:VP])--> 
   iv([inf:Inf,num:Num,sem:IV]), 
   {combine(vp:VP,[iv:IV])}.

vp([coord:no,inf:I,num:Num,gap:G,sem:VP])-->   
   tv([inf:I,num:Num,sem:TV]), 
   np([coord:_,num:_,gap:G,sem:NP]), 
   {combine(vp:VP,[tv:TV,np:NP])}.


/*========================================================================
   Prepositional Phrases
========================================================================*/

pp([sem:PP])--> 
   prep([sem:Prep]), 
   np([coord:_,num:_,gap:[],sem:NP]), 
   {combine(pp:PP,[prep:Prep,np:NP])}.


/*========================================================================
   Relative Clauses
========================================================================*/

rc([sem:RC])--> 
   relpro([sem:RP]), 
   vp([coord:_,inf:fin,num:sg,gap:[],sem:VP]), 
   {combine(rc:RC,[relpro:RP,vp:VP])}.


/*========================================================================
   Lexical Rules
========================================================================*/

iv([inf:Inf,num:Num,sem:Sem])--> 
   {lexEntry(iv,[symbol:Sym,syntax:Word,inf:Inf,num:Num])},
   Word,
   {semLex(iv,[symbol:Sym,sem:Sem])}.

tv([inf:Inf,num:Num,sem:Sem])--> 
   {lexEntry(tv,[symbol:Sym,syntax:Word,inf:Inf,num:Num])},
   Word,
   {semLex(tv,[symbol:Sym,sem:Sem])}.

cop([inf:Inf,num:Num,sem:Sem])--> 
   {lexEntry(cop,[pol:Pol,syntax:Word,inf:Inf,num:Num])},
   Word,
   {semLex(cop,[pol:Pol,sem:Sem])}.

det([mood:M,type:Type,sem:Det])--> 
   {lexEntry(det,[syntax:Word,mood:M,type:Type])},
   Word,
   {semLex(det,[type:Type,sem:Det])}. 

pn([sem:Sem])--> 
   {lexEntry(pn,[symbol:Sym,syntax:Word])},
   Word,  
   {semLex(pn,[symbol:Sym,sem:Sem])}.

relpro([sem:Sem])--> 
   {lexEntry(relpro,[syntax:Word])},
   Word,
   {semLex(relpro,[sem:Sem])}.

prep([sem:Sem])--> 
   {lexEntry(prep,[symbol:Sym,syntax:Word])},
   Word,
   {semLex(prep,[symbol:Sym,sem:Sem])}.

adj([sem:Sem])--> 
   {lexEntry(adj,[symbol:Sym,syntax:Word])},
   Word,
   {semLex(adj,[symbol:Sym,sem:Sem])}.

av([inf:Inf,num:Num,sem:Sem])--> 
   {lexEntry(av,[syntax:Word,inf:Inf,num:Num,pol:Pol])},
   Word,
   {semLex(av,[pol:Pol,sem:Sem])}.

coord([type:Type,sem:Sem])--> 
   {lexEntry(coord,[syntax:Word,type:Type])},
   Word, 
   {semLex(coord,[type:Type,sem:Sem])}.

qnp([mood:M,sem:NP])--> 
   {lexEntry(qnp,[symbol:Symbol,syntax:Word,mood:M,type:Type])},
   Word,
   {semLex(qnp,[type:Type,symbol:Symbol,sem:NP])}.

noun([sem:Sem])--> 
   {lexEntry(noun,[symbol:Sym,syntax:Word])},
   Word,
   {semLex(noun,[symbol:Sym,sem:Sem])}.



/*************************************************************************

    File: englishLexicon.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Determiners
========================================================================*/

lexEntry(det,[syntax:[every],mood:decl,type:uni]).
lexEntry(det,[syntax:[a],mood:decl,type:indef]).
lexEntry(det,[syntax:[the],mood:decl,type:def]).
lexEntry(det,[syntax:[which],mood:int,type:wh]).


/*========================================================================
   Nouns
========================================================================*/

lexEntry(noun,[symbol:animal,syntax:[animal]]).
lexEntry(noun,[symbol:beverage,syntax:[beverage]]).
lexEntry(noun,[symbol:building,syntax:[building]]).
lexEntry(noun,[symbol:cup,syntax:[cup]]).
lexEntry(noun,[symbol:burger,syntax:[burger]]).
lexEntry(noun,[symbol:boxer,syntax:[boxer]]).
lexEntry(noun,[symbol:boss,syntax:[boss]]).
lexEntry(noun,[symbol:car,syntax:[car]]).
lexEntry(noun,[symbol:chainsaw,syntax:[chainsaw]]).
lexEntry(noun,[symbol:criminal,syntax:[criminal]]).
lexEntry(noun,[symbol:customer,syntax:[customer]]).
lexEntry(noun,[symbol:drug,syntax:[drug]]).
lexEntry(noun,[symbol:episode,syntax:[episode]]).
lexEntry(noun,[symbol:fdshake,syntax:[five,dollar,shake]]).
lexEntry(noun,[symbol:footmassage,syntax:[foot,massage]]).
lexEntry(noun,[symbol:gimp,syntax:[gimp]]).
lexEntry(noun,[symbol:glass,syntax:[glass]]).
lexEntry(noun,[symbol:gun,syntax:[gun]]).
lexEntry(noun,[symbol:hammer,syntax:[hammer]]).
lexEntry(noun,[symbol:hashbar,syntax:[hash,bar]]).
lexEntry(noun,[symbol:person,syntax:[person]]).
lexEntry(noun,[symbol:husband,syntax:[husband]]).
lexEntry(noun,[symbol:joke,syntax:[joke]]).
lexEntry(noun,[symbol:man,syntax:[man]]).
lexEntry(noun,[symbol:needle,syntax:[needle]]).
lexEntry(noun,[symbol:owner,syntax:[owner]]).
lexEntry(noun,[symbol:piercing,syntax:[piercing]]).
lexEntry(noun,[symbol:plant,syntax:[plant]]).
lexEntry(noun,[symbol:qpwc,syntax:[quarter,pounder,with,cheese]]).
lexEntry(noun,[symbol:radio,syntax:[radio]]).
lexEntry(noun,[symbol:restaurant,syntax:[restaurant]]).
lexEntry(noun,[symbol:robber,syntax:[robber]]).
lexEntry(noun,[symbol:suitcase,syntax:[suitcase]]).
lexEntry(noun,[symbol:shotgun,syntax:[shotgun]]).
lexEntry(noun,[symbol:sword,syntax:[sword]]).
lexEntry(noun,[symbol:vehicle,syntax:[vehicle]]).
lexEntry(noun,[symbol:weapon,syntax:[weapon]]).
lexEntry(noun,[symbol:wife,syntax:[wife]]).
lexEntry(noun,[symbol:woman,syntax:[woman]]).


/*========================================================================
   Proper Names
========================================================================*/

lexEntry(pn,[symbol:butch,syntax:[butch]]).
lexEntry(pn,[symbol:esmarelda,syntax:[esmarelda]]).
lexEntry(pn,[symbol:honey_bunny,syntax:[honey,bunny]]).
lexEntry(pn,[symbol:jimmy,syntax:[jimmy]]).
lexEntry(pn,[symbol:jody,syntax:[jody]]).
lexEntry(pn,[symbol:jules,syntax:[jules]]).
lexEntry(pn,[symbol:lance,syntax:[lance]]).
lexEntry(pn,[symbol:marsellus,syntax:[marsellus]]).
lexEntry(pn,[symbol:marsellus,syntax:[marsellus,wallace]]).
lexEntry(pn,[symbol:marvin,syntax:[marvin]]).
lexEntry(pn,[symbol:mia,syntax:[mia]]).
lexEntry(pn,[symbol:mia,syntax:[mia,wallace]]).
lexEntry(pn,[symbol:pumpkin,syntax:[pumpkin]]).
lexEntry(pn,[symbol:thewolf,syntax:[the,wolf]]).
lexEntry(pn,[symbol:vincent,syntax:[vincent]]).
lexEntry(pn,[symbol:vincent,syntax:[vincent,vega]]).
lexEntry(pn,[symbol:yolanda,syntax:[yolanda]]).


/*========================================================================
   Quantified Noun Phrases
========================================================================*/

lexEntry(qnp,[symbol:person,syntax:[who],mood:int,type:wh]).
lexEntry(qnp,[symbol:thing,syntax:[what],mood:int,type:wh]).


/*========================================================================
   Intransitive Verbs
========================================================================*/

lexEntry(iv,[symbol:collapse,syntax:[collapse],inf:inf,num:sg]).
lexEntry(iv,[symbol:collapse,syntax:[collapses],inf:fin,num:sg]).
lexEntry(iv,[symbol:collapse,syntax:[collapse],inf:fin,num:pl]).

lexEntry(iv,[symbol:dance,syntax:[dance],inf:inf,num:sg]).
lexEntry(iv,[symbol:dance,syntax:[dances],inf:fin,num:sg]).
lexEntry(iv,[symbol:dance,syntax:[dance],inf:fin,num:pl]).

lexEntry(iv,[symbol:die,syntax:[die],inf:inf,num:sg]).
lexEntry(iv,[symbol:die,syntax:[dies],inf:fin,num:sg]).
lexEntry(iv,[symbol:die,syntax:[die],inf:fin,num:pl]).

lexEntry(iv,[symbol:growl,syntax:[growl],inf:inf,num:sg]).
lexEntry(iv,[symbol:growl,syntax:[growls],inf:fin,num:sg]).
lexEntry(iv,[symbol:growl,syntax:[growl],inf:fin,num:pl]).

lexEntry(iv,[symbol:playairguitar,syntax:[play,air,guitar],inf:inf,num:sg]).
lexEntry(iv,[symbol:playairguitar,syntax:[plays,air,guitar],inf:fin,num:sg]).
lexEntry(iv,[symbol:playairguitar,syntax:[play,air,guitar],inf:fin,num:pl]).

lexEntry(iv,[symbol:smoke,syntax:[smoke],inf:inf,num:sg]).
lexEntry(iv,[symbol:smoke,syntax:[smokes],inf:fin,num:sg]).
lexEntry(iv,[symbol:smoke,syntax:[smoke],inf:fin,num:pl]).

lexEntry(iv,[symbol:snort,syntax:[snort],inf:inf,num:sg]).
lexEntry(iv,[symbol:snort,syntax:[snorts],inf:fin,num:sg]).
lexEntry(iv,[symbol:snort,syntax:[snort],inf:fin,num:pl]).

lexEntry(iv,[symbol:shriek,syntax:[shriek],inf:inf,num:sg]).
lexEntry(iv,[symbol:shriek,syntax:[shrieks],inf:fin,num:sg]).
lexEntry(iv,[symbol:shriek,syntax:[shriek],inf:fin,num:pl]).

lexEntry(iv,[symbol:walk,syntax:[walk],inf:inf,num:sg]).
lexEntry(iv,[symbol:walk,syntax:[walks],inf:fin,num:sg]).
lexEntry(iv,[symbol:walk,syntax:[walk],inf:fin,num:pl]).


/*========================================================================
   Transitive Verbs
========================================================================*/

lexEntry(tv,[symbol:clean,syntax:[clean],inf:inf,num:sg]).
lexEntry(tv,[symbol:clean,syntax:[cleans],inf:fin,num:sg]).
lexEntry(tv,[symbol:clean,syntax:[clean],inf:fin,num:pl]).

lexEntry(tv,[symbol:drink,syntax:[drink],inf:inf,num:sg]).
lexEntry(tv,[symbol:drink,syntax:[drinks],inf:fin,num:sg]).
lexEntry(tv,[symbol:drink,syntax:[drink],inf:fin,num:pl]).

lexEntry(tv,[symbol:date,syntax:[date],inf:inf,num:sg]).
lexEntry(tv,[symbol:date,syntax:[dates],inf:fin,num:sg]).
lexEntry(tv,[symbol:date,syntax:[date],inf:fin,num:pl]).

lexEntry(tv,[symbol:discard,syntax:[discard],inf:inf,num:sg]).
lexEntry(tv,[symbol:discard,syntax:[discards],inf:fin,num:sg]).
lexEntry(tv,[symbol:discard,syntax:[discard],inf:fin,num:pl]).

lexEntry(tv,[symbol:eat,syntax:[eat],inf:inf,num:sg]).
lexEntry(tv,[symbol:eat,syntax:[eats],inf:fin,num:sg]).
lexEntry(tv,[symbol:eat,syntax:[eat],inf:fin,num:pl]).

lexEntry(tv,[symbol:enjoy,syntax:[enjoy],inf:inf,num:sg]).
lexEntry(tv,[symbol:enjoy,syntax:[enjoys],inf:fin,num:sg]).
lexEntry(tv,[symbol:enjoy,syntax:[enjoy],inf:fin,num:pl]).

lexEntry(tv,[symbol:hate,syntax:[hate],inf:inf,num:sg]).
lexEntry(tv,[symbol:hate,syntax:[hates],inf:fin,num:sg]).
lexEntry(tv,[symbol:hate,syntax:[hate],inf:fin,num:pl]).

lexEntry(tv,[symbol:have,syntax:[have],inf:inf,num:sg]).
lexEntry(tv,[symbol:have,syntax:[has],inf:fin,num:sg]).
lexEntry(tv,[symbol:have,syntax:[have],inf:fin,num:pl]).

lexEntry(tv,[symbol:kill,syntax:[kill],inf:inf,num:sg]).
lexEntry(tv,[symbol:kill,syntax:[kills],inf:fin,num:sg]).
lexEntry(tv,[symbol:kill,syntax:[kill],inf:fin,num:pl]).

lexEntry(tv,[symbol:know,syntax:[know],inf:inf,num:sg]).
lexEntry(tv,[symbol:know,syntax:[knows],inf:fin,num:sg]).
lexEntry(tv,[symbol:know,syntax:[know],inf:fin,num:pl]).

lexEntry(tv,[symbol:like,syntax:[like],inf:inf,num:sg]).
lexEntry(tv,[symbol:like,syntax:[likes],inf:fin,num:sg]).
lexEntry(tv,[symbol:like,syntax:[like],inf:fin,num:pl]).

lexEntry(tv,[symbol:love,syntax:[love],inf:inf,num:sg]).
lexEntry(tv,[symbol:love,syntax:[loves],inf:fin,num:sg]).
lexEntry(tv,[symbol:love,syntax:[love],inf:fin,num:pl]).

lexEntry(tv,[symbol:pickup,syntax:[pick,up],inf:inf,num:sg]).
lexEntry(tv,[symbol:pickup,syntax:[picks,up],inf:fin,num:sg]).
lexEntry(tv,[symbol:pickup,syntax:[pick,up],inf:fin,num:pl]).

lexEntry(tv,[symbol:shoot,syntax:[shot],inf:inf,num:sg]).
lexEntry(tv,[symbol:shoot,syntax:[shot],inf:fin,num:sg]).
lexEntry(tv,[symbol:shoot,syntax:[shoots],inf:fin,num:sg]).
lexEntry(tv,[symbol:shoot,syntax:[shoot],inf:fin,num:pl]).


/*========================================================================
   Copula
========================================================================*/

lexEntry(cop,[pol:pos,syntax:[is],inf:fin,num:sg]).
lexEntry(cop,[pol:neg,syntax:[is,not],inf:fin,num:sg]).
lexEntry(cop,[pol:pos,syntax:[are],inf:fin,num:pl]).
lexEntry(cop,[pol:neg,syntax:[are,not],inf:fin,num:pl]).


/*========================================================================
   Prepositions
========================================================================*/

lexEntry(prep,[symbol:about,syntax:[about]]).
lexEntry(prep,[symbol:in,syntax:[in]]).
lexEntry(prep,[symbol:of,syntax:[of]]).
lexEntry(prep,[symbol:with,syntax:[with]]).
lexEntry(prep,[symbol:without,syntax:[without]]).


/*========================================================================
   Adjectives
========================================================================*/

lexEntry(adj,[symbol:big,syntax:[big]]).
lexEntry(adj,[symbol:blue,syntax:[blue]]).
lexEntry(adj,[symbol:female,syntax:[female]]).
lexEntry(adj,[symbol:happy,syntax:[happy]]).
lexEntry(adj,[symbol:kahuna,syntax:[kahuna]]).
lexEntry(adj,[symbol:male,syntax:[male]]).
lexEntry(adj,[symbol:married,syntax:[married]]).
lexEntry(adj,[symbol:red,syntax:[red]]).
lexEntry(adj,[symbol:sad,syntax:[sad]]).
lexEntry(adj,[symbol:small,syntax:[small]]).
lexEntry(adj,[symbol:tall,syntax:[tall]]).


/*========================================================================
   Relative Pronouns
========================================================================*/

lexEntry(relpro,[syntax:[who]]).
lexEntry(relpro,[syntax:[that]]).


/*========================================================================
   Coordinations
========================================================================*/

lexEntry(coord,[syntax:[and],type:conj]).
lexEntry(coord,[syntax:[or],type:disj]).


/*========================================================================
   Auxiliary Verbs
========================================================================*/

lexEntry(av,[syntax:[does],inf:fin,num:sg,pol:pos]).
lexEntry(av,[syntax:[does,not],inf:fin,num:sg,pol:neg]).
lexEntry(av,[syntax:[did],inf:fin,num:sg,pol:pos]).
lexEntry(av,[syntax:[did,not],inf:fin,num:sg,pol:neg]).


/*************************************************************************

    File: exampleModels.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(exampleModels,[example/2]).


/*========================================================================
   Example Models
========================================================================*/

example(1,
        model([d1,d2,d3,d4,d5],
              [f(0,jules,d1),
               f(0,vincent,d2),
               f(0,pumpkin,d3),
               f(0,honey_bunny,d4),
               f(0,yolanda,d5),
               f(1,customer,[d1,d2]),
               f(1,robber,[d3,d4]),
               f(2,love,[(d3,d4)])])).


example(2,
        model([d1,d2,d3,d4,d5,d6],
              [f(0,jules,d1),
               f(0,vincent,d2),
               f(0,pumpkin,d3),
               f(0,honey_bunny,d4),
               f(0,yolanda,d4),
               f(1,customer,[d1,d2,d5,d6]),
               f(1,robber,[d3,d4]),
               f(2,love,[])])).


example(3,
        model([d1,d2,d3,d4,d5,d6,d7,d8],
              [f(0,mia,d1),
               f(0,jody,d2),
               f(0,jules,d3),
               f(0,vincent,d4),
               f(1,woman,[d1,d2]),
               f(1,man,[d3,d4]),
               f(1,joke,[d5,d6]),
               f(1,episode,[d7,d8]),
               f(2,in,[(d5,d7),(d5,d8)]),
               f(2,tell,[(d1,d5),(d2,d6)])])).

example(4,model([d1,d7,d9],[f(2,accessible_world,[(d9,d9),(d9,d7),(d1,d9),(d1,d7),(d1,d1)])])).
example(5,model([d1,d7,d9],[f(2,accessible_world,[(d9,d9),(d9,d7),(d1,d9),(d1,d1)])])).
example(6,model([d9,d7,d1],[f(2,accessible_world,[(d9,d9),(d9,d7),(d1,d9),(d1,d7),(d1,d1)])])).


/*************************************************************************

    File: experiment1.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- use_module(comsemPredicates,[infix/0,prefix/0]).


/*========================================================================
   Syntax-Semantics Rules 
========================================================================*/

s(Sem)--> np(Sem), vp(SemVP), 
   {
    arg(1,SemVP,X),
    arg(1,Sem,X),
    arg(2,Sem,Matrix),
    arg(2,Matrix,SemVP)
   }.
            
s(Sem)--> np(SemNP), vp(Sem), 
   {
    arg(1,Sem,SemNP)
   }.

np(Sem)--> pn(Sem).

np(Sem)--> det(Sem), noun(SemNoun), 
   {
    arg(1,SemNoun,X),
    arg(1,Sem,X),
    arg(2,Sem,Matrix),
    arg(1,Matrix,SemNoun)
   }.

vp(Sem)--> iv(Sem).

vp(Sem)--> tv(SemTV), np(Sem), 
   {
    arg(2,SemTV,X),
    arg(1,Sem,X),
    arg(2,Sem,Matrix),
    arg(2,Matrix,SemTV)
   }.

vp(Sem)--> tv(Sem), np(SemNP), 
   { 
    arg(2,Sem,SemNP)
   }.


/*========================================================================
   Proper Names
========================================================================*/

pn(vincent)--> [vincent].
pn(mia)--> [mia].


/*========================================================================
   Transitive Verbs
========================================================================*/

tv(love(_,_))--> [loves].
tv(like(_,_))--> [likes].


/*========================================================================
   Intransitive Verbs
========================================================================*/

iv(snort(_))--> [snorts].
iv(walk(_))--> [walks].


/*========================================================================
   Determiners
========================================================================*/

det(some(_,and(_,_)))--> [a].
det(all(_,imp(_,_)))--> [every].


/*========================================================================
   Nouns
========================================================================*/

noun(woman(_))--> [woman].
noun(footmassage(_))--> [foot,massage].







/*************************************************************************

    File: experiment2.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- use_module(comsemPredicates,[infix/0,prefix/0]).


/*========================================================================
   Syntax-semantics rules 
========================================================================*/

s(Sem)--> np(X,SemVP,Sem), vp(X,SemVP).

np(X,Scope,Sem)--> det(X,Restr,Scope,Sem), noun(X,Restr). 

np(SemPN,Sem,Sem)--> pn(SemPN).

vp(X,Sem)--> iv(X,Sem).

vp(X,Sem)--> tv(X,Y,SemTV), np(Y,SemTV,Sem). 


/*========================================================================
   Proper Names
========================================================================*/

pn(vincent)--> [vincent].
pn(mia)--> [mia].


/*========================================================================
   Transitive Verbs
========================================================================*/

tv(Y,Z,love(Y,Z))--> [loves].
tv(Y,Z,like(Y,Z))--> [likes].


/*========================================================================
   Intransitive Verbs
========================================================================*/

iv(Y,snort(Y))--> [snorts].
iv(Y,walk(Y))--> [walks].


/*========================================================================
   Determiners
========================================================================*/

det(X,Restr,Scope,some(X,and(Restr,Scope)))--> [a].
det(X,Restr,Scope,all(X,imp(Restr,Scope)))--> [every].


/*========================================================================
   Nouns
========================================================================*/

noun(X,woman(X))--> [woman].
noun(X,footmassage(X))--> [foot,massage].


/*************************************************************************

    File: experiment3.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- use_module(betaConversion,[betaConvert/2]).

:- use_module(comsemPredicates,[infix/0,prefix/0]).


/*========================================================================
   Syntax-semantics rules 
========================================================================*/

s(app(NP,VP))--> np(NP), vp(VP).

np(app(Det,Noun))--> det(Det), noun(Noun). 

np(PN)--> pn(PN).

vp(IV)--> iv(IV).

vp(app(TV,NP))--> tv(TV), np(NP). 


/*========================================================================
   Proper Names
========================================================================*/

pn(lam(P,app(P,vincent)))--> [vincent].

pn(lam(P,app(P,mia)))--> [mia].


/*========================================================================
   Transitive Verbs
========================================================================*/

tv(lam(X,lam(Y,app(X,lam(Z,love(Y,Z))))))--> [loves].
tv(lam(X,lam(Y,app(X,lam(Z,like(Y,Z))))))--> [likes].


/*========================================================================
   Intransitive Verbs
========================================================================*/

iv(lam(Y,snort(Y)))--> [snorts].
iv(lam(Y,walk(Y)))--> [walks].


/*========================================================================
   Determiners
========================================================================*/

det(lam(P,lam(Q,all(X,imp(app(P,X),app(Q,X))))))--> [every].

det(lam(P,lam(Q,some(X,and(app(P,X),app(Q,X))))))--> [a].


/*========================================================================
   Nouns
========================================================================*/

noun(lam(X,woman(X)))--> [woman].

noun(lam(X,footmassage(X)))--> [foot,massage].




/*************************************************************************

    File: fol2bliksem.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(fol2bliksem,[fol2bliksem/2]).

:- use_module(comsemPredicates,[basicFormula/1]).


/*========================================================================
   Translates formula to otter syntax on Stream
========================================================================*/

fol2bliksem(Formula,Stream):-
	nonvar(Formula),
	printBliksemFormula(Stream,Formula).


/*========================================================================
   Print an Bliksem formula (introducing tab)
========================================================================*/

printBliksemFormula(Stream,F):-
	   format(Stream,'~nAuto.~n~n',[]),
	   \+ \+ (
		     numbervars(F,0,_),
		     printBliksem(Stream,F,5)
		 ),
	   format(Stream,'.~n',[]).


/*========================================================================
   Print Bliksem formulas
========================================================================*/

printBliksem(Stream,some(X,Formula),Tab):- 
   write(Stream,'(< '),
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,' >'),
   printBliksem(Stream,Formula,Tab),
   write(Stream,')').

printBliksem(Stream,all(X,Formula),Tab):- 
   write(Stream,'([ '),
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,' ]'),
   printBliksem(Stream,Formula,Tab),
   write(Stream,')').

printBliksem(Stream,que(X,Formula1,Formula2),Tab):- 
   write(Stream,'(< '),
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,' >'),
   printBliksem(Stream,and(Formula1,Formula2),Tab),
   write(Stream,')').

printBliksem(Stream,and(Phi,Psi),Tab):- 
   write(Stream,'('),
   printBliksem(Stream,Phi,Tab), 
   format(Stream,' & ~n',[]),
   tab(Stream,Tab),
   NewTab is Tab + 5,
   printBliksem(Stream,Psi,NewTab),
   write(Stream,')').

printBliksem(Stream,or(Phi,Psi),Tab):- 
   write(Stream,'('),
   printBliksem(Stream,Phi,Tab),
   write(Stream,' | '),
   printBliksem(Stream,Psi,Tab),
   write(Stream,')').

printBliksem(Stream,imp(Phi,Psi),Tab):- 
   write(Stream,'('),  
   printBliksem(Stream,Phi,Tab),
   write(Stream,' -> '),
   printBliksem(Stream,Psi,Tab),
   write(Stream,')').

printBliksem(Stream,not(Phi),Tab):-
   write(Stream,'!'),
   printBliksem(Stream,Phi,Tab).

printBliksem(Stream,eq(X,Y),_):- 
   write(Stream,'( '),
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,' = '),
   write_term(Stream,Y,[numbervars(true)]),
   write(Stream,' )').

printBliksem(Stream,Phi,_):-
   basicFormula(Phi),
   write_term(Stream,Phi,[numbervars(true)]).


/*************************************************************************

    File: fol2latex.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/


fol2file(F):-
    open('test.tex',write,Stream),
    write(Stream,'\\documentstyle{article}'),
    nl(Stream),
    write(Stream,'\\begin{document}'),
    nl(Stream),
    numbervars(F,0,_),
    fol2latex(F,Stream),
    nl(Stream),
    write(Stream,'\\end{document}'),
    nl(Stream),
    close(Stream).

fol2latex(F):-
    fol2latex(F,user).


fol2latex(some(X,F),Stream):- !,
    write(Stream,'$\\exists$'),
    write_term(Stream,X,[numbervars(true)]),
    fol2latex(F,Stream).

fol2latex(all(X,F),Stream):- !,
    write(Stream,'$\\forall$'),
    write_term(Stream,X,[numbervars(true)]),
    fol2latex(F,Stream).

fol2latex(lam(X,F),Stream):- !,
    write(Stream,'$\\lambda$'),
    write_term(Stream,X,[numbervars(true)]),
    fol2latex(F,Stream).

fol2latex(que(X,F1,F2),Stream):- !,
    write(Stream,'?'),
    write_term(Stream,X,[numbervars(true)]),
    write(Stream,'('),
    fol2latex(F1,Stream),
    write(Stream,','),
    fol2latex(F2,Stream),
    write(Stream,')').

fol2latex(and(F1,F2),Stream):- !,
    write(Stream,'('),
    fol2latex(F1,Stream),
    write(Stream,' $\\land$ '),
    fol2latex(F2,Stream),
    write(Stream,')').

fol2latex(imp(F1,F2),Stream):- !,
    write(Stream,'('),
    fol2latex(F1,Stream),
    write(Stream,' $\\to$ '),
    fol2latex(F2,Stream),
    write(Stream,')').

fol2latex(or(F1,F2),Stream):- !,
    write(Stream,'('),
    fol2latex(F1,Stream),
    write(Stream,' $\\lor$ '),
    fol2latex(F2,Stream),
    write(Stream,')').

fol2latex(app(F1,F2),Stream):- !,
    write(Stream,'('),
    fol2latex(F1,Stream),
    write(Stream,'@'),
    fol2latex(F2,Stream),
    write(Stream,')').

fol2latex(leq(X,Y),Stream):- !,
    write_term(Stream,X,[numbervars(true)]),
    write(Stream,'$\\leq$'),
    write_term(Stream,Y,[numbervars(true)]).

fol2latex(not(F),Stream):- !,
    write(Stream,'$\\neg$'),
    fol2latex(F,Stream).

fol2latex(pred1(L,S,X),Stream):- !, 
    write_term(Stream,L,[numbervars(true)]),
    write(Stream,':\\textsc{'),
    write_term(Stream,S,[numbervars(true)]),
    write(Stream,'}('),
    write_term(Stream,X,[numbervars(true)]),
    write(Stream,')').

fol2latex(pred2(L,S,X,Y),Stream):- !,
    write_term(Stream,L,[numbervars(true)]),
    write(Stream,':\\textsc{'),
    write_term(Stream,S,[numbervars(true)]),
    write(Stream,'}('),
    write_term(Stream,X,[numbervars(true)]),
    write(Stream,','),
    write_term(Stream,Y,[numbervars(true)]),
    write(Stream,')').

fol2latex(eq(L,X,Y),Stream):- !,
    write_term(Stream,L,[numbervars(true)]),
    write(Stream,':'),
    write_term(Stream,X,[numbervars(true)]),
    write(Stream,'='),
    write_term(Stream,Y,[numbervars(true)]).

fol2latex(F,Stream):-
    F =.. [Symbol,Arg],
    write(Stream,'\\textsc{'),
    write_term(Stream,Symbol,[numbervars(true)]),
    write(Stream,'}('),
    write_term(Stream,Arg,[numbervars(true)]),
    write(Stream,')').

fol2latex(F,Stream):-
    F =.. [Symbol,Arg1,Arg2],
    write(Stream,'\\textsc{'),
    write_term(Stream,Symbol,[numbervars(true)]),
    write(Stream,'}('),
    write_term(Stream,Arg1,[numbervars(true)]),
    write(Stream,','),
    write_term(Stream,Arg2,[numbervars(true)]),
    write(Stream,')').

fol2latex(F,Stream):-
    F =.. [Symbol,Arg1,Arg2,Arg3],
    write(Stream,'\\textsc{'),
    write_term(Stream,Symbol,[numbervars(true)]),
    write(Stream,'}('),
    write_term(Stream,Arg1,[numbervars(true)]),
    write(Stream,','),
    write_term(Stream,Arg2,[numbervars(true)]),
    write(Stream,','),
    write_term(Stream,Arg3,[numbervars(true)]),
    write(Stream,')').


/*************************************************************************

    File: fol2otter.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(fol2otter,[fol2otter/2,fol2mace/2]).

:- use_module(comsemPredicates,[basicFormula/1]).


/*========================================================================
   Translates formula to Otter syntax on Stream
========================================================================*/

fol2otter(Formula,Stream):- 
	format(Stream,'set(auto).~n~n',[]),
	format(Stream,'assign(max_seconds,30).~n~n',[]),
	format(Stream,'clear(print_proofs).~n~n',[]),
	format(Stream,'set(prolog_style_variables).~n~n',[]),
	format(Stream,'formula_list(usable).~n~n',[]),
	printOtterFormula(Stream,Formula),
	format(Stream,'~nend_of_list.~n',[]).


/*========================================================================
   Translates formula to MACE syntax on Stream
========================================================================*/

fol2mace(Formula,Stream):- 
	format(Stream,'set(auto).~n~n',[]),
	format(Stream,'clear(print_proofs).~n~n',[]),
	format(Stream,'set(prolog_style_variables).~n~n',[]),
	format(Stream,'formula_list(usable).~n~n',[]),
	printOtterFormula(Stream,Formula),
	format(Stream,'~nend_of_list.~n',[]).


/*========================================================================
   Print an Otter formula (introducing tab)
========================================================================*/

printOtterFormula(Stream,F):-
	   \+ \+ (
		     numbervars(F,0,_),
		     printOtter(Stream,F,5)
		 ),
	   format(Stream,'.~n',[]).


/*========================================================================
   Print Otter formulas
========================================================================*/

printOtter(Stream,some(X,Formula),Tab):- 
   write(Stream,'(exists '),
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,' '),
   printOtter(Stream,Formula,Tab),
   write(Stream,')').

printOtter(Stream,all(X,Formula),Tab):- 
   write(Stream,'(all '),
   write_term(Stream,X,[numbervars(true)]),   
   write(Stream,' '),
   printOtter(Stream,Formula,Tab),
   write(Stream,')').

printOtter(Stream,que(X,Formula1,Formula2),Tab):- 
   write(Stream,'(exists '),
   write_term(Stream,X,[numbervars(true)]),   
   write(Stream,' '),
   printOtter(Stream,and(Formula1,Formula2),Tab),
   write(Stream,')').

printOtter(Stream,and(Phi,Psi),Tab):- 
   write(Stream,'('),
   printOtter(Stream,Phi,Tab), 
   format(Stream,' & ~n',[]),
   tab(Stream,Tab),
   NewTab is Tab + 5,
   printOtter(Stream,Psi,NewTab),
   write(Stream,')').

printOtter(Stream,or(Phi,Psi),Tab):- 
   write(Stream,'('),
   printOtter(Stream,Phi,Tab),
   write(Stream,' | '),
   printOtter(Stream,Psi,Tab),
   write(Stream,')').

printOtter(Stream,imp(Phi,Psi),Tab):- 
   write(Stream,'('),  
   printOtter(Stream,Phi,Tab),
   write(Stream,' -> '),
   printOtter(Stream,Psi,Tab),
   write(Stream,')').

printOtter(Stream,not(Phi),Tab):- 
   write(Stream,'-('),
   printOtter(Stream,Phi,Tab),
   write(Stream,')').

printOtter(Stream,eq(X,Y),_):- 
   write(Stream,'('),  
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,' = '),
   write_term(Stream,Y,[numbervars(true)]),
   write(Stream,')').

printOtter(Stream,Phi,_):-
   basicFormula(Phi),
   write_term(Stream,Phi,[numbervars(true)]).


/*************************************************************************

    File: fol2tptp.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(fol2tptp,[fol2tptp/2]).

:- use_module(comsemPredicates,[basicFormula/1]).

/*========================================================================
   Translates formula to TPTP syntax on Stream
========================================================================*/

fol2tptp(Formula,Stream):- 
   write(Stream,'input_formula(comsem,conjecture,'),
   \+ \+ ( numbervars(Formula,0,_),printTptp(Formula,Stream) ),
   write(Stream,').'),
   nl(Stream).


/*========================================================================
   Print Tptp formulas
========================================================================*/

printTptp(some(X,Formula),Stream):- !,
   write(Stream,'(? ['),
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,']: '),
   printTptp(Formula,Stream),
   write(Stream,')').

printTptp(que(X,Formula),Stream):- !,
   write(Stream,'(? ['),
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,']: '),
   printTptp(Formula,Stream),
   write(Stream,')').

printTptp(all(X,Formula),Stream):- !,
   write(Stream,'(! ['),
   write_term(Stream,X,[numbervars(true)]),
   write(Stream,']: '),
   printTptp(Formula,Stream),
   write(Stream,')').

printTptp(and(Phi,Psi),Stream):- !,
   write(Stream,'('),
   printTptp(Phi,Stream), 
   write(Stream,' & '), 
   printTptp(Psi,Stream), 
   write(Stream,')').

printTptp(or(Phi,Psi),Stream):- !,
   write(Stream,'('),
   printTptp(Phi,Stream), 
   write(Stream,' | '),
   printTptp(Psi,Stream), 
   write(Stream,')').

printTptp(imp(Phi,Psi),Stream):- !,
   write(Stream,'('),
   printTptp(Phi,Stream), 
   write(Stream,' => '),
   printTptp(Psi,Stream), 
   write(Stream,')').

printTptp(not(Phi),Stream):- !,
   write(Stream,'~ '),
   printTptp(Phi,Stream).

printTptp(eq(X,Y),Stream):- !,
   write_term(Stream,equal(X,Y),[numbervars(true)]).

printTptp(Phi,Stream):-
   basicFormula(Phi),
   write_term(Stream,Phi,[numbervars(true)]).


/*************************************************************************

    File: folTestSuite.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(folTestSuite,[formula/2]).


/*========================================================================
   Formulas
========================================================================*/

formula(all(X,or(p(X),not(p(X)))),theorem).

formula(some(X,or(p(X),not(p(X)))),theorem).

formula(imp(all(X,p(X)),not(some(Y,not(p(Y))))),theorem).

formula(imp(all(X,imp(p(X),q(X))),imp(all(X,p(X)),all(X,q(X)))),theorem).

formula(imp(imp(p(a),all(X,q(X))),all(X,imp(p(a),q(X)))),theorem).

formula(imp(all(X,p(X)),p(c)),theorem).

formula(some(X,imp(p(X),all(X,p(X)))),theorem).

formula(imp(some(Y,all(X,r(X,Y))),all(X,some(Y,r(X,Y)))),theorem).

formula(imp(all(X,or(p(X),q(X))),or(some(X,p(X)),some(X,q(X)))),theorem).

formula(some(X,all(Y,all(Z,imp(imp(p(Y),q(Z)),imp(p(X),q(X)))))),theorem).

formula(some(X,all(Y,all(Z,imp(or(p(Y),q(Z)),or(p(X),q(X)))))),theorem).

formula(some(X,all(Y,all(Z,all(W,imp(or(p(Y),or(q(Z),r(W))), 
                                     or(p(X),or(q(X),r(X)))))))),theorem).

formula(imp(all(X,all(Y,and(p(X),p(Y)))),some(X,some(Y,or(p(X),p(Y))))),theorem).

formula(imp(all(X,all(Y,and(p(X),p(Y)))),all(X,all(Y,or(p(X),p(Y))))),theorem).

formula(all(X,some(Y,all(Z,some(W,or(r(X,Y),not(r(W,Z))))))),theorem).

formula(imp(and(all(X,e(X,X)),
                all(V1,all(V2,all(W1,all(W2,imp(and(e(V1,W1),e(V2,W2)), 
                                                imp(e(V1,V2),e(W1,W2)))))))),
            all(X,all(Y,all(Z,imp(e(X,Y),imp(e(Y,Z),e(X,Z))))))),theorem).


% Schubert's Steamroller
%
% Wolves, foxes, birds, caterpillars, and snails are animals, and
% there are some of each of them. Also there are some grains, and
% grains are plants. Every animal either likes to eat all plants
% or all animals much smaller than itself that like to eat some
% plants. Caterpillars and snails are much smaller than birds,
% which are much smaller than foxes, which in turn are much
% smaller than wolves. Wolves do not like to eat foxes or grains,
% while birds like to eat caterpillars but not snails.
% Caterpillars and snails like to eat some plants. Therefore
% there is an animal that likes to eat a grain eating animal.

formula(imp(and(all(X,imp(wolf(X),animal(X))),
            and(all(X,imp(fox(X),animal(X))),
            and(all(X,imp(bird(X),animal(X))),
            and(all(X,imp(caterpillar(X),animal(X))),
            and(all(X,imp(snail(X),animal(X))),
            and(all(X,imp(grain(X),plant(X))),
            and(some(Y,wolf(Y)),
            and(some(Y,fox(Y)),
            and(some(Y,bird(Y)),
            and(some(Y,caterpillar(Y)),
            and(some(Y,snail(Y)),
            and(some(Y,grain(Y)),
            and(all(X,imp(animal(X),or(all(Y,imp(plant(Y),eats(X,Y))),
                    all(Y1,imp(and(animal(Y1),and(much_smaller(Y1,X),
                        some(Z,and(plant(Z),eats(Y1,Z))))),eats(X,Y1)))))),
            and(all(X,all(Y,imp(and(bird(Y),or(snail(X),caterpillar(X))),
                much_smaller(X,Y)))),
            and(all(X,all(Y,imp(and(bird(X),fox(Y)),much_smaller(X,Y)))),
            and(all(X,all(Y,imp(and(fox(X),wolf(Y)),much_smaller(X,Y)))),
            and(all(X,all(Y,imp(and(wolf(X),or(fox(X),grain(Y))),not(eats(X,Y))))),
            and(all(X,all(Y,imp(and(bird(X),caterpillar(Y)),eats(X,Y)))),
            and(all(X,all(Y,imp(and(bird(X),snail(Y)),not(eats(X,Y))))),
                all(X,imp(or(caterpillar(X),snail(X)),
                      some(Y,and(plant(Y),eats(X,Y)))))))))))))))))))))))),
            some(X,some(Y,and(animal(X),and(animal(Y),some(Z,and(
                 grain(Z),and(eats(Y,Z),eats(X,Y))))))))),theorem).

formula(some(X,and(man(X),some(Y,woman(Y)))),satisfiable).

formula(some(X,and(man(X),all(Y,imp(woman(Y),love(X,Y))))),satisfiable).

formula(all(Y,imp(woman(Y),some(X,and(man(X),love(X,Y))))),satisfiable).

formula(some(X,or(p(X),q(X))),satisfiable).

formula(some(X,and(p(X),not(p(X)))),unsatisfiable).


/*************************************************************************

    File: foResolution.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(foResolution,[info/0,
                        infix/0,
                        prefix/0,
                        rprove/1,
                        rprove/2,
                        rproveTestSuite/0]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
				appendLists/3,
                                unionSets/3,
				selectFromList/3]).

:- use_module(folTestSuite,[formula/2]).

:- use_module(cnfFOL,[cnf/2]).


/*========================================================================
   Main Predicate
========================================================================*/

rprove(Formula):-
   cnf(not(Formula),CNF),
   nonRedundantFactors(CNF,NRF),
   refute(NRF).

rprove(Formula,Result):-
   cnf(not(Formula),CNF),
   nonRedundantFactors(CNF,NRF),
   (
      refute(NRF), !,
      Result = 'theorem'
   ;
      Result = 'not a theorem'
   ).
      

/*========================================================================
   Try all formulas from the test suite
========================================================================*/

rproveTestSuite:-
   format('~n~n>>>>> FOL RESOLUTION PROVER ON TEST SUITE <<<<<~n',[]),
   formula(Formula,Status),
   format('~nInput formula: ~p~nStatus: ~p',[Formula,Status]),
   rprove(Formula,Result), 
   format('~nProver: ~p~n',[Result]),
   fail.

rproveTestSuite.


/*========================================================================
   Refute
========================================================================*/

refute(C):-
   memberList([],C).

refute(C):-
   \+ memberList([],C),
   resolveList(C,[],Output),
   unionSets(Output,C,NewC),
   \+ NewC == C,
   refute(NewC).


/*========================================================================
   Resolve a list against a list
========================================================================*/

resolveList([],Acc,Acc).

resolveList([Clause|List],Acc1,Acc3):-
   resolveClauseList(List,Clause,Acc1,Acc2),
   resolveList(List,Acc2,Acc3).


/*========================================================================
   Resolve a clause against a list
========================================================================*/

resolveClauseList([],_,Acc,Acc).

resolveClauseList([H|L],Clause,Acc,Output):-
   resolve(Clause,H,Result0),
   nonRedundantFactors([Result0],Result), 
   unionSets(Result,Acc,NewAcc),
   resolveClauseList(L,Clause,NewAcc,Output).

resolveClauseList([H|L],Clause,Acc1,Acc2):-
   \+ resolve(Clause,H,_),
   resolveClauseList(L,Clause,Acc1,Acc2).


/*========================================================================
   Resolve two clauses
========================================================================*/

resolve(Clause1,Clause2,NewClause):-
   selectFromList(Lit1,Clause1,Temp1),
   selectFromList(not(Lit2),Clause2,Temp2), 
   unify_with_occurs_check(Lit1,Lit2),
   unionSets(Temp1,Temp2,NewClause).

resolve(Clause1,Clause2,NewClause):-
   selectFromList(not(Lit1),Clause1,Temp1),
   selectFromList(Lit2,Clause2,Temp2),
   unify_with_occurs_check(Lit1,Lit2),
   unionSets(Temp1,Temp2,NewClause).


/*========================================================================
   Compute Non-Redundant Factors for a list of clauses
========================================================================*/

nonRedundantFactors([],[]).

nonRedundantFactors([C1|L1],L4):-
   findall(C2,nonRedFact(C1,C2),L3),
   nonRedundantFactors(L1,L2),
   appendLists(L3,L2,L4).


/*========================================================================
   Compute Non-Redundant Factors for a Clause
========================================================================*/

nonRedFact([],[]).
   
nonRedFact([X|C1],C2):-
   memberList(Y,C1),
   unify_with_occurs_check(X,Y),
   nonRedFact(C1,C2).

nonRedFact([X|C1],[X|C2]):-
   nonRedFact(C1,C2).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> -------------------------------------------------------------------- <',[]),
   format('~n> foResolution.pl, by Patrick Blackburn and Johan Bos                  <',[]),
   format('~n>                                                                      <',[]),
   format('~n> ?- rprove(Formula).         - Succeeds if Formula is a theorem       <',[]),
   format('~n> ?- rprove(Formula,Result).  - Try to prove Formula, return result    <',[]),
   format('~n> ?- rproveTestSuite.         - Run the test suite for theorem proving <',[]),
   format('~n> ?- infix.                   - switches to infix display mode         <',[]),
   format('~n> ?- prefix.                  - switches to prefix display mode        <',[]),
   format('~n> ?- info.                    - show this information                  <',[]),
   format('~n> -------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: freeVarTabl.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(freeVarTabl,[info/0,
                       infix/0,
                       prefix/0,
                       tprove/1,
                       tprove/2,
		       tprove/3,
		       tproveTestSuite/0]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
				removeFirst/3,
				appendLists/3,
                                basicFormula/1,
                                compose/3,
				newFunctionCounter/1,
                                substitute/4]).

:- use_module(folTestSuite,[formula/2]).


/*========================================================================
   Expand Tableau until it is closed, allowing Qdepth 
   applications of the universal rule.
========================================================================*/

closedTableau([],_Q):- !.

closedTableau(OldTableau,Qdepth):-
   expand(OldTableau,Qdepth,TempTableau,NewQdepth), !,
   removeClosedBranches(TempTableau,NewTableau),
   closedTableau(NewTableau,NewQdepth).


/*========================================================================
   Remove all closed branches
========================================================================*/

removeClosedBranches([],[]).

removeClosedBranches([Branch|Rest],Tableau):-
   closedBranch(Branch), !,
   removeClosedBranches(Rest,Tableau).

removeClosedBranches([Branch|Rest],[Branch|Tableau]):-
   removeClosedBranches(Rest,Tableau).


/*========================================================================
   Check whether a branch is closed
========================================================================*/

closedBranch(Branch):-
   memberList(n(_,t(X)),Branch),
   memberList(n(_,f(Y)),Branch),
   basicFormula(X), 
   basicFormula(Y),
   unify_with_occurs_check(X,Y).


/*========================================================================
   VarList is a list of free variables, and SkolemTerm is a previously 
   unused Skolem function symbol fun(N) applied to those free variables.
========================================================================*/

skolemFunction(VarList,SkolemTerm):-
   newFunctionCounter(N),
   compose(SkolemTerm,fun,[N|VarList]).


/*========================================================================
   Try to create a tableau expansion for f(X) that is closed allowing 
   Qdepth applications of the universal rule.
========================================================================*/

tprove(X,Qdepth):-
   notatedFormula(NotatedFormula,[],f(X)),
   closedTableau([[NotatedFormula]],Qdepth).

tprove(X,Qdepth,Result):-
   notatedFormula(NotatedFormula,[],f(X)),
   (
      closedTableau([[NotatedFormula]],Qdepth), !,
      Result = theorem
   ;
      Result = unknown
   ).


/*========================================================================
   Prove a formula with Q-depth of 100 (default)
========================================================================*/

tprove(X):-
   tprove(X,1000).


/*========================================================================
   Notate the free variables of a formula
========================================================================*/

notatedFormula(n(Free,Formula),Free,Formula).


/*========================================================================
   Prove all formulas from the test suite 
========================================================================*/

tproveTestSuite:-
   format('~n~n>>>>> FREE VARIABLE TABLEAU ON TEST SUITE <<<<<',[]),
   formula(Formula,Status),
   format('~n~nInput formula: ~p~nStatus: ~p',[Formula,Status]),
   tprove(Formula,100,Result), 
   format('~nProver: ~p~n',[Result]),
   fail.

tproveTestSuite.


/*========================================================================
   Newtableau with Q-depth NewQdepth is the result of applying  
   a tableau expansion rule to Oldtableau with a Q-depth of OldQdepth.
========================================================================*/

expand([Branch|Tableau],QD,[NewBranch|Tableau],QD):-
   unaryExpansion(Branch,NewBranch).

expand([Branch|Tableau],QD,[NewBranch|Tableau],QD):-
   conjunctiveExpansion(Branch,NewBranch).

expand([Branch|Tableau],QD,[NewBranch|Tableau],QD):-
   existentialExpansion(Branch,NewBranch).

expand([Branch|Tableau],QD,[NewBranch1,NewBranch2|Tableau],QD):-
   disjunctiveExpansion(Branch,NewBranch1,NewBranch2).

expand([Branch|Tableau],OldQD,NewTableau,NewQD):-
   universalExpansion(Branch,OldQD,NewBranch,NewQD),
   appendLists(Tableau,[NewBranch],NewTableau).

expand([Branch|Rest],OldQD,[Branch|Newrest],NewQD):-
   expand(Rest,OldQD,Newrest,NewQD).


/*========================================================================
   Take Branch as input, and return NewBranches if a tableau rule
   allows unary expansion.
========================================================================*/

unaryExpansion(Branch,[NotatedComponent|Temp]) :-
   unary(SignedFormula,Component),
   notatedFormula(NotatedFormula,Free,SignedFormula),
   removeFirst(NotatedFormula,Branch,Temp),
   notatedFormula(NotatedComponent,Free,Component).


/*========================================================================
   Take Branch as input, and return the NewBranch if a tableau rule 
   allows conjunctive expansion. 
========================================================================*/

conjunctiveExpansion(Branch,[NotatedComp1,NotatedComp2|Temp]):-
   conjunctive(SignedFormula,Comp1,Comp2),
   notatedFormula(NotatedFormula,Free,SignedFormula),
   removeFirst(NotatedFormula,Branch,Temp),
   notatedFormula(NotatedComp1,Free,Comp1),
   notatedFormula(NotatedComp2,Free,Comp2).


/*========================================================================
   Take Branch as input, and return the NewBranch1 and NewBranch2 
   if a tableau rule allows disjunctive expansion. 
========================================================================*/

disjunctiveExpansion(Branch,[NotComp1|Temp],[NotComp2|Temp]):-
   disjunctive(SignedFormula,Comp1,Comp2),
   notatedFormula(NotatedFormula,Free,SignedFormula),
   removeFirst(NotatedFormula,Branch,Temp),
   notatedFormula(NotComp1,Free,Comp1),
   notatedFormula(NotComp2,Free,Comp2).


/*========================================================================
   Take Branch as input, and return the NewBranch if a tableau rule 
   allows existential expansion.
========================================================================*/

existentialExpansion(Branch,[NotatedInstance|Temp]):-
   notatedFormula(NotatedFormula,Free,SignedFormula),
   existential(SignedFormula),
   removeFirst(NotatedFormula,Branch,Temp),
   skolemFunction(Free,Term),
   instance(SignedFormula,Term,Instance),
   notatedFormula(NotatedInstance,Free,Instance).


/*========================================================================
   Take Branch and OldQD as input, and return the NewBranch and 
   NewQDepthif a tableau rule allow universal expansion.
========================================================================*/

universalExpansion(Branch,OldQD,NewBranch,NewQD):-
   OldQD > 0, 
   NewQD is OldQD - 1,
   memberList(NotatedFormula,Branch),
   notatedFormula(NotatedFormula,Free,SignedFormula),
   universal(SignedFormula),
   removeFirst(NotatedFormula,Branch,Temp),
   instance(SignedFormula,V,Instance),
   notatedFormula(NotatedInstance,[V|Free],Instance),
   appendLists([NotatedInstance|Temp],[NotatedFormula],NewBranch).


/*========================================================================
   Decompose conjunctive signed formula
========================================================================*/

conjunctive(t(and(X,Y)),t(X),t(Y)).
conjunctive(f(or(X,Y)),f(X),f(Y)).
conjunctive(f(imp(X,Y)),t(X),f(Y)).


/*========================================================================
   Decompose disjunctive signed formula
========================================================================*/

disjunctive(f(and(X,Y)),f(X),f(Y)).
disjunctive(t(or(X,Y)),t(X),t(Y)).
disjunctive(t(imp(X,Y)),f(X),t(Y)).


/*========================================================================
   Decompose unary signed formula
========================================================================*/

unary(t(not(X)),f(X)).
unary(f(not(X)),t(X)). 


/*========================================================================
   Universal Signed Formulas
========================================================================*/

universal(t(all(_,_))).
universal(f(some(_,_))).


/*========================================================================
   Existential Signed Formulas
========================================================================*/

existential(t(some(_,_))).
existential(f(all(_,_))).


/*========================================================================
   Remove quantifier from signed quantified formula, and replacing all
   free occurrences of the quantified variable by occurrences of Term.
========================================================================*/

instance(t(all(X,F)),Term,t(NewF)):- substitute(Term,X,F,NewF).
instance(f(some(X,F)),Term,f(NewF)):- substitute(Term,X,F,NewF).
instance(t(some(X,F)),Term,t(NewF)):- substitute(Term,X,F,NewF).
instance(f(all(X,F)),Term,f(NewF)):- substitute(Term,X,F,NewF).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ----------------------------------------------------------------------------- <',[]),
   format('~n> freeVarTabl.pl, by Patrick Blackburn and Johan Bos                            <',[]),
   format('~n>                                                                               <',[]),
   format('~n> ?- tprove(Form).            - Try to prove Form                               <',[]),
   format('~n> ?- tprove(Form,QDepth).     - Try to prove Form using QDepth                  <',[]),
   format('~n> ?- tprove(Form,QDepth,Res). - Try to prove Form using QDepth, return Res      <',[]),
   format('~n> ?- tproveTestSuite.         - runs the test suite for theorem proving         <',[]),
   format('~n> ?- infix.                   - switches to infix display mode                  <',[]),
   format('~n> ?- prefix.                  - switches to prefix display mode                 <',[]),
   format('~n> ?- info.                    - show this information                           <',[]),
   format('~n> ----------------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: helpfulCurt.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(curt,[curt/0,infix/0,prefix/0]).

:- use_module(callInference,[callTP/3,
                             callTPandMB/6]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
                                compose/3,
				selectFromList/3,
				printRepresentations/1]).

:- use_module(kellerStorage,[kellerStorage/2]).

:- use_module(modelChecker2,[satisfy/4]).

:- use_module(backgroundKnowledge,[backgroundKnowledge/2]).

:- use_module(elimEquivReadings,[elimEquivReadings/2]).

:- use_module(curtPredicates,[curtHelp/0,
                              curtOutput/1,
                              updateReadings/1,
                              updateModels/1,
                              updateHistory/1,
                              clearHistory/0,
                              list2string/2,
                              selectReadings/3]).


/*========================================================================
   Dynamic Predicates
========================================================================*/

:- dynamic history/1, readings/1, models/1.

history([]).
readings([]).
models([]).


/*========================================================================
   Start Curt
========================================================================*/

curt:- 
   curtTalk(run).


/*========================================================================
   Control
========================================================================*/

curtTalk(quit).

curtTalk(run):-
   readLine(Input),
   curtUpdate(Input,CurtsMoves,State), 
   curtOutput(CurtsMoves),
   curtTalk(State).


/*========================================================================
   Update Curt's Information State
========================================================================*/

curtUpdate([],[clarify],run):- !.

curtUpdate([bye],[bye],quit):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([new],[],run):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([help],[],run):- !,
   curtHelp.

curtUpdate([infix],[],run):- !,
   infix.

curtUpdate([prefix],[],run):- !,
   prefix.

curtUpdate([select,X],[],run):-
   number(X),
   readings(R1),
   selectReadings(X,R1,R2), !,
   updateReadings(R2),
   models(M1),
   selectReadings(X,M1,M2),
   updateModels(M2).

curtUpdate([summary],[],run):-
   readings(Readings),
   elimEquivReadings(Readings,Unique),
   updateReadings(Unique),
   updateModels([]).

curtUpdate([knowledge],[],run):-
   readings(R), 
   findall(K,(memberList(F,R),backgroundKnowledge(F,K)),L),
   printRepresentations(L).
   
curtUpdate([readings],[],run):- !,
   readings(R),
   printRepresentations(R).

curtUpdate([models],[],run):- !,
   models(M),
   printRepresentations(M).

curtUpdate([history],[],run):- !,
   history(H),
   printRepresentations(H).

curtUpdate(Input,Moves,run):-
   kellerStorage(Input,Readings), !,
   updateHistory(Input),
   (
      Readings=[que(X,R,S)|_],
      models(OldModels),
      answerQuestion(que(X,R,S),OldModels,Moves)
   ;  
      \+ Readings=[que(_,_,_)|_],
      consistentReadings(Readings,[]-ConsReadings,[]-Models),
      (
         ConsReadings=[],
         Moves=[contradiction]
      ;
         \+ ConsReadings=[],
         informativeReadings(ConsReadings,[]-InfReadings),   
         (
            InfReadings=[],
            Moves=[obvious]
         ;  
            \+ InfReadings=[],
            Moves=[accept]
         ),
         combine(ConsReadings,CombinedReadings), 
         updateReadings(CombinedReadings),
         updateModels(Models)
      )
   ).

curtUpdate(_,[noparse],run).


/*========================================================================
   Combine New Utterances with History
========================================================================*/

combine(New,New):-
   readings([]).

combine(Readings,Updated):-
   readings([Old|_]),
   findall(and(Old,New),memberList(New,Readings),Updated).


/*========================================================================
   Select Consistent Readings
========================================================================*/

consistentReadings([],C-C,M-M).

consistentReadings([New|Readings],C1-C2,M1-M2):-
   readings(Old),
   (
      consistent(Old,New,Model), !,
      consistentReadings(Readings,[New|C1]-C2,[Model|M1]-M2) 
   ;
      consistentReadings(Readings,C1-C2,M1-M2) 
   ).


/*========================================================================
   Consistency Checking calling Theorem Prover and Model Builder
========================================================================*/

consistent([Old|_],New,Model):-
   backgroundKnowledge(and(Old,New),BK),
   DomainSize=15,
   callTPandMB(not(and(and(BK,Old),New)),and(and(BK,Old),New),DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).

consistent([],New,Model):-
   backgroundKnowledge(New,BK),
   DomainSize=15,
   callTPandMB(not(and(BK,New)),and(BK,New),DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
   Select Informative Readings
========================================================================*/

informativeReadings([],I-I).

informativeReadings([New|L],I1-I2):-
   readings(Old),
   (
      informative(Old,New), !,
      informativeReadings(L,[New|I1]-I2) 
   ;
      informativeReadings(L,I1-I2) 
   ).


/*========================================================================
   Informativity Checking calling Theorem Prover
========================================================================*/

informative([Old|_],New):-
   backgroundKnowledge(and(Old,New),BK),
   DomainSize=15,
   callTPandMB(not(and(and(BK,Old),not(New))),and(and(BK,Old),not(New)),DomainSize,Proof,Model,Engine),
   format('~nMessage (informativity checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).  

informative([],New):-
   backgroundKnowledge(New,BK),
   DomainSize=15,
   callTPandMB(not(and(BK,not(New))),and(BK,not(New)),DomainSize,Proof,Model,Engine),
   format('~nMessage (informativity checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
    Answer Questions
========================================================================*/

answerQuestion(que(X,R,S),Models,Moves):-
   (
      Models=[Model|_],
      satisfy(some(X,and(R,S)),Model,[],Result), 
      \+ Result=undef,
      !,     
      findall(A,satisfy(and(R,S),Model,[g(X,A)],pos),Answers),
      realiseAnswer(Answers,que(X,R,S),Model,String),
      Moves=[sensible_question,answer(String)]
   ;
      Moves=[unknown_answer]
   ).


/*========================================================================
    Realise all answers
========================================================================*/

realiseAnswer([],_,_,'none').

realiseAnswer([Value],Q,Model,String):-
   realiseString(Q,Value,Model,String).

realiseAnswer([Value1,Value2|Values],Q,Model,String):-
   realiseString(Q,Value1,Model,String1),
   realiseAnswer([Value2|Values],Q,Model,String2),
   list2string([String1,and,String2],String).


/*========================================================================
    Realise a single answer
========================================================================*/

realiseString(que(X,R,S),Value,Model,String):-
   kellerStorage:lexEntry(pn,[symbol:Symbol,syntax:Answer|_]),
   satisfy(eq(Y,Symbol),Model,[g(Y,Value)],pos), !,
   checkAnswer(some(X,and(eq(X,Symbol),and(R,S))),Proof),
   (
      Proof=proof, !,
      list2string(Answer,String)
   ;
      list2string([maybe|Answer],String)
   ).

realiseString(que(X,R,S),Value,Model,String):-
   kellerStorage:lexEntry(noun,[symbol:Symbol,syntax:Answer|_]), 
   compose(Formula,Symbol,[X]),
   satisfy(Formula,Model,[g(X,Value)],pos), !,
   checkAnswer(some(X,and(Formula,and(R,S))),Proof),
   (
      Proof=proof, !,
      list2string([a|Answer],String)
   ;
      list2string([maybe,a|Answer],String)
   ).

realiseString(_,Value,_,Value).


/*========================================================================
   Answer Checking
========================================================================*/

checkAnswer(Answer,Proof):-
   readings([F|_]),
   backgroundKnowledge(F,BK),
   callTP(imp(and(F,BK),Answer),Proof,Engine),
   format('~nMessage (answer checking): ~p found result "~p".',[Engine,Proof]).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n> helpfulCurt.pl, by Patrick Blackburn and Johan Bos         <',[]),
   format('~n>                                                            <',[]),
   format('~n> ?- curt.                - start a dialogue with Curt       <',[]),
   format('~n>                                                            <',[]),
   format('~n> Type "help" to get more information about features         <',[]),
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n~n',[]).



/*========================================================================
   Display info at start
========================================================================*/

:- info.

 


/*************************************************************************

    File: holeSemantics.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(holeSemantics,[info/0,
                         prefix/0,
                         infix/0,
                         holeSemantics/0,
			 holeSemantics/2,
			 holeSemanticsTestSuite/0]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                printRepresentations/1]).

:- use_module(sentenceTestSuite,[sentence/2]).

:- use_module(pluggingAlgorithm,[plugUSR/2]).

:- use_module(betaConversion,[betaConvert/2]).

:- [englishGrammar].

:- [englishLexicon].

:- [semLexHole].

:- [semRulesHole].


/*========================================================================
   Driver Predicates
========================================================================*/

holeSemantics:-
   readLine(Sentence),
   t([sem:USR],Sentence,[]),   
   printRepresentations([USR]),
   setof(Sem,plugUSR(USR,Sem),Sems),
   printRepresentations(Sems).

holeSemantics(Sentence,Sems):-
   t([sem:USR],Sentence,[]),   
   setof(Sem,plugUSR(USR,Sem),Sems).


/*========================================================================
   Testsuite Predicates
========================================================================*/

holeSemanticsTestSuite:-
   nl, write('>>>>> HOLE SEMANTICS ON SENTENCE TEST SUITE <<<<< '), nl,
   sentence(Sentence,Readings),
   format('~nSentence: ~p (~p readings)',[Sentence,Readings]),
   holeSemantics(Sentence,Sems),
   printRepresentations(Sems),
   fail.

holeSemanticsTestSuite.


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> holeSemantics.pl, by Patrick Blackburn and Johan Bos                <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- holeSemantics.            - parse a typed-in sentence            <',[]),
   format('~n> ?- holeSemantics(S,F).       - parse a sentence and return formulas <',[]),
   format('~n> ?- holeSemanticsTestSuite.   - run the test suite                   <',[]),
   format('~n> ?- infix.                    - switches to infix display mode       <',[]),
   format('~n> ?- prefix.                   - switches to prefix display mode      <',[]),
   format('~n> ?- info.                     - show this information                <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.


/*************************************************************************

    File: inferenceEngines.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Choose Inference Engines
========================================================================*/

%inferenceEngines([paradox,bliksem]).
%inferenceEngines([paradox,otter]).
inferenceEngines([mace,otter]).
%inferenceEngines([otter,paradox,bliksem,mace]).


/*************************************************************************

    File: kellerStorage.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(kellerStorage,[infix/0,
                         prefix/0,
                         info/0,
                         kellerStorage/0,
			 kellerStorage/2,
			 kellerStorageTestSuite/0]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[memberList/2,
				appendLists/3,
				selectFromList/3,
				compose/3,
                                infix/0,
                                prefix/0,
				printRepresentations/1]).

:- use_module(alphaConversion,[alphabeticVariants/2]).

:- use_module(betaConversion,[betaConvert/2]).

:- [englishGrammar].

:- [englishLexicon].

:- use_module(sentenceTestSuite,[sentence/2]).

:- [semLexStorage].

:- [semRulesKeller].


/*========================================================================
   Driver Predicates
========================================================================*/

kellerStorage:-
   readLine(Sentence),
   setof(Sem,t([sem:Sem],Sentence,[]),Sems1),
   filterAlphabeticVariants(Sems1,Sems2),
   printRepresentations(Sems2).

kellerStorage(Sentence,Sems2):-
   setof(Sem,t([sem:Sem],Sentence,[]),Sems1),
   filterAlphabeticVariants(Sems1,Sems2).


/*========================================================================
   Test Suite Predicates
========================================================================*/

kellerStorageTestSuite:-
   nl, write('>>>>> KELLER STORAGE ON SENTENCE TEST SUITE <<<<< '), nl,
   sentence(Sentence,Readings),
   format('~nSentence: ~p (~p readings)',[Sentence,Readings]),
   kellerStorage(Sentence,Sems),
   printRepresentations(Sems),
   fail.

kellerStorageTestSuite.


/*========================================================================
   Filter Alphabetic Variants
========================================================================*/

filterAlphabeticVariants(L1,L2):-
   selectFromList(X,L1,L3),
   memberList(Y,L3),
   alphabeticVariants(X,Y), !,
   filterAlphabeticVariants(L3,L2).

filterAlphabeticVariants(L,L).


/*========================================================================
   Quantifier Retrieval
========================================================================*/

sRetrieval([S],S).

sRetrieval([Sem|Store],S):-
   selectFromList(bo([Q|NestedStore],X),Store,TempStore),
   appendLists(NestedStore,TempStore,NewStore),
   sRetrieval([app(Q,lam(X,Sem))|NewStore],S).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> kellerStorage.pl, by Patrick Blackburn and Johan Bos                <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- kellerStorage.            - parse a typed-in sentence            <',[]),
   format('~n> ?- kellerStorage(S,F).       - parse a sentence and return formulas <',[]),
   format('~n> ?- kellerStorageTestSuite.   - run the test suite                   <',[]),
   format('~n> ?- infix.                    - switches to infix display mode       <',[]),
   format('~n> ?- prefix.                   - switches to prefix display mode      <',[]),
   format('~n> ?- info.                     - show this information                <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.


/*************************************************************************

    File: knowledgeableCurt.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(curt,[curt/0,infix/0,prefix/0]).

:- use_module(callInference,[callTPandMB/6]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
				printRepresentations/1]).

:- use_module(kellerStorage,[kellerStorage/2]).

:- use_module(backgroundKnowledge,[backgroundKnowledge/2]).

:- use_module(elimEquivReadings,[elimEquivReadings/2]).

:- use_module(curtPredicates,[curtHelp/0,
                              curtOutput/1,
                              updateReadings/1,
                              updateModels/1,
                              updateHistory/1,
                              clearHistory/0,
                              selectReadings/3]).


/*========================================================================
   Dynamic Predicates
========================================================================*/

:- dynamic history/1, readings/1, models/1.

history([]).
readings([]).
models([]).


/*========================================================================
   Start Curt
========================================================================*/

curt:- 
   curtTalk(run).


/*========================================================================
   Control
========================================================================*/

curtTalk(quit).

curtTalk(run):-
   readLine(Input),
   curtUpdate(Input,CurtsMoves,State), 
   curtOutput(CurtsMoves),
   curtTalk(State).


/*========================================================================
   Update Curt's Information State
========================================================================*/

curtUpdate([],[clarify],run):- !.

curtUpdate([bye],[bye],quit):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([new],[],run):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([help],[],run):- !,
   curtHelp.

curtUpdate([infix],[],run):- !,
   infix.

curtUpdate([prefix],[],run):- !,
   prefix.

curtUpdate([select,X],[],run):-
   number(X),
   readings(R1),
   selectReadings(X,R1,R2), !,
   updateReadings(R2),
   models(M1),
   selectReadings(X,M1,M2),
   updateModels(M2).

curtUpdate([summary],[],run):-
   readings(Readings),
   elimEquivReadings(Readings,Unique),
   updateReadings(Unique),
   updateModels([]).

curtUpdate([knowledge],[],run):-
   readings(R), 
   findall(K,(memberList(F,R),backgroundKnowledge(F,K)),L),
   printRepresentations(L).
   
curtUpdate([readings],[],run):- !,
   readings(R),
   printRepresentations(R).

curtUpdate([models],[],run):- !,
   models(M),
   printRepresentations(M).

curtUpdate([history],[],run):- !,
   history(H),
   printRepresentations(H).

curtUpdate(Input,Moves,run):-
   kellerStorage(Input,Readings), !,
   updateHistory(Input),
   consistentReadings(Readings,[]-ConsReadings,[]-Models),
   (
      ConsReadings=[],
      Moves=[contradiction]
   ;
      \+ ConsReadings=[],
      informativeReadings(ConsReadings,[]-InfReadings),   
      (
         InfReadings=[],
         Moves=[obvious]
      ;  
         \+ InfReadings=[],
         Moves=[accept]
      ),
      combine(ConsReadings,CombinedReadings), 
      updateReadings(CombinedReadings),
      updateModels(Models)
   ).

curtUpdate(_,[noparse],run).


/*========================================================================
   Combine New Utterances with History
========================================================================*/

combine(New,New):-
   readings([]).

combine(Readings,Updated):-
   readings([Old|_]),
   findall(and(Old,New),memberList(New,Readings),Updated).


/*========================================================================
   Select Consistent Readings
========================================================================*/

consistentReadings([],C-C,M-M).

consistentReadings([New|Readings],C1-C2,M1-M2):-
   readings(Old),
   (
      consistent(Old,New,Model), !,
      consistentReadings(Readings,[New|C1]-C2,[Model|M1]-M2) 
   ;
      consistentReadings(Readings,C1-C2,M1-M2) 
   ).


/*========================================================================
   Consistency Checking calling Theorem Prover and Model Builder
========================================================================*/

consistent([Old|_],New,Model):-
   backgroundKnowledge(and(Old,New),BK),
   DomainSize=15,
   callTPandMB(not(and(and(BK,Old),New)),and(and(BK,Old),New),DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).

consistent([],New,Model):-
   backgroundKnowledge(New,BK),
   DomainSize=15,
   callTPandMB(not(and(BK,New)),and(BK,New),DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
   Select Informative Readings
========================================================================*/

informativeReadings([],I-I).

informativeReadings([New|L],I1-I2):-
   readings(Old),
   (
      informative(Old,New), !,
      informativeReadings(L,[New|I1]-I2) 
   ;
      informativeReadings(L,I1-I2) 
   ).


/*========================================================================
   Informativity Checking calling Theorem Prover
========================================================================*/

informative([Old|_],New):-
   backgroundKnowledge(and(Old,New),BK),
   DomainSize=15,
   callTPandMB(not(and(and(BK,Old),not(New))),and(and(BK,Old),not(New)),DomainSize,Proof,Model,Engine),
   format('~nMessage (informativity checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).

informative([],New):-
   backgroundKnowledge(New,BK),
   DomainSize=15,
   callTPandMB(not(and(BK,not(New))),and(BK,not(New)),DomainSize,Proof,Model,Engine),
   format('~nMessage (informativity checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n> knowledgableCurt.pl, by Patrick Blackburn and Johan Bos    <',[]),
   format('~n>                                                            <',[]),
   format('~n> ?- curt.                - start a dialogue with Curt       <',[]),
   format('~n>                                                            <',[]),
   format('~n> Type "help" to get more information about features         <',[]),
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n~n',[]).



/*========================================================================
   Display info at start
========================================================================*/

:- info.

 


/*************************************************************************

    File: lambda.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(lambda,[info/0,
                  infix/0,
                  prefix/0,
                  lambda/0,
                  lambda/2,
                  lambdaTestSuite/0]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                printRepresentations/1,
				compose/3]).

:- use_module(betaConversion,[betaConvert/2]).

:- use_module(sentenceTestSuite,[sentence/2]).

:- [englishGrammar].

:- [englishLexicon].

:- [semLexLambda].

:- [semRulesLambda].


/*========================================================================
   Driver Predicates
========================================================================*/

lambda:-
	readLine(Sentence),
        lambda(Sentence,Sems),
	printRepresentations(Sems).

lambda(Sentence,Sems):-
	setof(Sem,t([sem:Sem],Sentence,[]),Sems).


/*========================================================================
   Test Suite Predicates
========================================================================*/

lambdaTestSuite:-
	nl, write('>>>>> LAMBDA ON SENTENCE TEST SUITE <<<<< '), nl,
        sentence(Sentence,_),
        nl, write('Sentence: '), write(Sentence),
	lambda(Sentence,Formulas),
	printRepresentations(Formulas),
        fail.

lambdaTestSuite.


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------ <',[]),
   format('~n> lambda.pl, by Patrick Blackburn and Johan Bos                      <',[]),
   format('~n>                                                                    <',[]),
   format('~n> ?- lambda.              - parse a typed-in sentence                <',[]),
   format('~n> ?- lambda(S,F).         - parse a sentence and return formula      <',[]),
   format('~n> ?- lambdaTestSuite.     - run the test suite                       <',[]),
   format('~n> ?- infix.               - switches to infix display mode           <',[]),
   format('~n> ?- prefix.              - switches to prefix display mode          <',[]),
   format('~n> ?- info.                - shows this information                   <',[]),
   format('~n> ------------------------------------------------------------------ <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.


/*************************************************************************

    File: lexicalKnowledge.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(lexicalKnowledge,[lexicalKnowledge/3]).

/*========================================================================
   Axioms for Lexical Knowledge: Nouns
========================================================================*/

lexicalKnowledge(event,1,Axiom):-
   Axiom = all(A,imp(event(A),thing(A))).

lexicalKnowledge(entity,1,Axiom):- 
   Axiom = all(A,imp(entity(A),thing(A))).

lexicalKnowledge(object,1,Axiom):- 
   Axiom = all(A,imp(object(A),entity(A))).

lexicalKnowledge(organism,1,Axiom):- 
   Axiom = all(A,imp(organism(A),entity(A))).

lexicalKnowledge(food,1,Axiom):- 
   Axiom = all(A,imp(food(A),object(A))).

lexicalKnowledge(artifact,1,Axiom):- 
   Axiom = all(A,imp(artifact(A),object(A))).

lexicalKnowledge(building,1,Axiom):- 
   Axiom = all(A,imp(building(A),artifact(A))).

lexicalKnowledge(instrument,1,Axiom):- 
   Axiom = all(A,imp(instrument(A),artifact(A))).

lexicalKnowledge(animal,1,Axiom):- 
   Axiom = all(A,imp(animal(A),organism(A))).

lexicalKnowledge(person,1,Axiom):- 
   Axiom = all(A,imp(person(A),organism(A))).

lexicalKnowledge(plant,1,Axiom):- 
   Axiom = all(A,imp(plant(A),organism(A))).

lexicalKnowledge(man,1,Axiom):- 
   Axiom = all(A,imp(man(A),person(A))).

lexicalKnowledge(woman,1,Axiom):- 
   Axiom = all(A,imp(woman(A),person(A))).

lexicalKnowledge(beverage,1,Axiom):- 
   Axiom = all(A,imp(beverage(A),food(A))).

lexicalKnowledge(foodstuff,1,Axiom):- 
   Axiom = all(A,imp(foodstuff(A),food(A))).

lexicalKnowledge(container,1,Axiom):- 
   Axiom = all(A,imp(container(A),instrument(A))).

lexicalKnowledge(device,1,Axiom):- 
   Axiom = all(A,imp(device(A),instrument(A))).

lexicalKnowledge(cup,1,Axiom):- 
   Axiom = all(A,imp(cup(A),container(A))).

lexicalKnowledge(glass,1,Axiom):- 
   Axiom = all(A,imp(glass(A),container(A))).

lexicalKnowledge(burger,1,Axiom):- 
   Axiom = all(A,imp(burger(A),foodstuff(A))).

lexicalKnowledge(qpwc,1,Axiom):- 
   Axiom = all(A,imp(qpwc(A),foodstuff(A))).

lexicalKnowledge(boxer,1,Axiom):- 
   Axiom = all(A,imp(boxer(A),person(A))).

lexicalKnowledge(boss,1,Axiom):- 
   Axiom = all(A,imp(boss(A),person(A))).

lexicalKnowledge(criminal,1,Axiom):- 
   Axiom = all(A,imp(criminal(A),person(A))).

lexicalKnowledge(customer,1,Axiom):- 
   Axiom = all(A,imp(customer(A),person(A))).

lexicalKnowledge(owner,1,Axiom):- 
   Axiom = all(A,imp(owner(A),person(A))).

lexicalKnowledge(robber,1,Axiom):- 
   Axiom = all(A,imp(robber(A),person(A))).

lexicalKnowledge(vehicle,1,Axiom):- 
   Axiom = all(A,imp(vehicle(A),instrument(A))).

lexicalKnowledge(car,1,Axiom):- 
   Axiom = all(A,imp(car(A),vehicle(A))).

lexicalKnowledge(chainsaw,1,Axiom):- 
   Axiom = all(A,imp(chainsaw(A),device(A))).

lexicalKnowledge(drug,1,Axiom):- 
   Axiom = all(A,imp(drug(A),artifact(A))).

lexicalKnowledge(episode,1,Axiom):- 
   Axiom = all(A,imp(episode(A),event(A))).

lexicalKnowledge(footmassage,1,Axiom):- 
   Axiom = all(A,imp(footmassage(A),event(A))).

lexicalKnowledge(fdshake,1,Axiom):- 
   Axiom = all(A,imp(fdshake(A),beverage(A))).

lexicalKnowledge(weapon,1,Axiom):- 
   Axiom = all(A,imp(weapon(A),instrument(A))).

lexicalKnowledge(gun,1,Axiom):- 
   Axiom = all(A,imp(gun(A),weapon(A))).

lexicalKnowledge(hammer,1,Axiom):- 
   Axiom = all(A,imp(hammer(A),device(A))).

lexicalKnowledge(hashbar,1,Axiom):- 
   Axiom = all(A,imp(hashbar(A),building(A))).

lexicalKnowledge(restaurant,1,Axiom):- 
   Axiom = all(A,imp(restaurant(A),building(A))).

lexicalKnowledge(husband,1,Axiom):- 
   Axiom = all(A,imp(husband(A),man(A))).

lexicalKnowledge(joke,1,Axiom):- 
   Axiom = all(A,imp(joke(A),event(A))).

lexicalKnowledge(needle,1,Axiom):- 
   Axiom = all(A,imp(needle(A),device(A))).

lexicalKnowledge(piercing,1,Axiom):- 
   Axiom = all(A,imp(piercing(A),artifact(A))).

lexicalKnowledge(radio,1,Axiom):- 
   Axiom = all(A,imp(radio(A),instrument(A))).

lexicalKnowledge(suitcase,1,Axiom):- 
   Axiom = all(A,imp(suitcase(A),container(A))).

lexicalKnowledge(shotgun,1,Axiom):- 
   Axiom = all(A,imp(shotgun(A),gun(A))).

lexicalKnowledge(sword,1,Axiom):- 
   Axiom = all(A,imp(sword(A),weapon(A))).

lexicalKnowledge(wife,1,Axiom):- 
   Axiom = all(A,imp(wife(A),woman(A))).

lexicalKnowledge(entity,1,Axiom):- 
   Axiom = all(A,imp(entity(A),not(event(A)))).

lexicalKnowledge(organism,1,Axiom):- 
   Axiom = all(A,imp(organism(A),not(object(A)))).

lexicalKnowledge(artifact,1,Axiom):- 
   Axiom = all(A,imp(artifact(A),not(food(A)))).

lexicalKnowledge(person,1,Axiom):- 
   Axiom = all(A,imp(person(A),not(animal(A)))).

lexicalKnowledge(plant,1,Axiom):- 
   Axiom = all(A,imp(plant(A),not(animal(A)))).

lexicalKnowledge(plant,1,Axiom):- 
   Axiom = all(A,imp(plant(A),not(person(A)))).

lexicalKnowledge(instrument,1,Axiom):- 
   Axiom = all(A,imp(instrument(A),not(building(A)))).

lexicalKnowledge(drug,1,Axiom):- 
   Axiom = all(A,imp(drug(A),not(building(A)))).

lexicalKnowledge(piercing,1,Axiom):- 
   Axiom = all(A,imp(piercing(A),not(building(A)))).

lexicalKnowledge(drug,1,Axiom):- 
   Axiom = all(A,imp(drug(A),not(instrument(A)))).

lexicalKnowledge(piercing,1,Axiom):- 
   Axiom = all(A,imp(piercing(A),not(instrument(A)))).

lexicalKnowledge(piercing,1,Axiom):- 
   Axiom = all(A,imp(piercing(A),not(drug(A)))).

lexicalKnowledge(woman,1,Axiom):- 
   Axiom = all(A,imp(woman(A),not(man(A)))).

lexicalKnowledge(device,1,Axiom):- 
   Axiom = all(A,imp(device(A),not(radio(A)))).

lexicalKnowledge(container,1,Axiom):- 
   Axiom = all(A,imp(container(A),not(radio(A)))).

lexicalKnowledge(vehicle,1,Axiom):- 
   Axiom = all(A,imp(vehicle(A),not(radio(A)))).

lexicalKnowledge(weapon,1,Axiom):- 
   Axiom = all(A,imp(weapon(A),not(radio(A)))).

lexicalKnowledge(container,1,Axiom):- 
   Axiom = all(A,imp(container(A),not(device(A)))).

lexicalKnowledge(vehicle,1,Axiom):- 
   Axiom = all(A,imp(vehicle(A),not(device(A)))).

lexicalKnowledge(weapon,1,Axiom):- 
   Axiom = all(A,imp(weapon(A),not(device(A)))).

lexicalKnowledge(vehicle,1,Axiom):- 
   Axiom = all(A,imp(vehicle(A),not(container(A)))).

lexicalKnowledge(weapon,1,Axiom):- 
   Axiom = all(A,imp(weapon(A),not(container(A)))).

lexicalKnowledge(weapon,1,Axiom):- 
   Axiom = all(A,imp(weapon(A),not(vehicle(A)))).

lexicalKnowledge(beverage,1,Axiom):- 
   Axiom = all(A,imp(beverage(A),not(foodstuff(A)))).

lexicalKnowledge(footmassage,1,Axiom):- 
   Axiom = all(A,imp(footmassage(A),not(episode(A)))).

lexicalKnowledge(joke,1,Axiom):- 
   Axiom = all(A,imp(joke(A),not(episode(A)))).

lexicalKnowledge(joke,1,Axiom):- 
   Axiom = all(A,imp(joke(A),not(footmassage(A)))).

lexicalKnowledge(cup,1,Axiom):- 
   Axiom = all(A,imp(cup(A),not(glass(A)))).

lexicalKnowledge(suitcase,1,Axiom):- 
   Axiom = all(A,imp(suitcase(A),not(glass(A)))).

lexicalKnowledge(suitcase,1,Axiom):- 
   Axiom = all(A,imp(suitcase(A),not(cup(A)))).

lexicalKnowledge(chainsaw,1,Axiom):- 
   Axiom = all(A,imp(chainsaw(A),not(hammer(A)))).

lexicalKnowledge(needle,1,Axiom):- 
   Axiom = all(A,imp(needle(A),not(hammer(A)))).

lexicalKnowledge(needle,1,Axiom):- 
   Axiom = all(A,imp(needle(A),not(chainsaw(A)))).

lexicalKnowledge(unmarried,1,Axiom):- 
   Axiom = all(A,imp(unmarried(A),not(married(A)))).

lexicalKnowledge(burger,1,Axiom):- 
   Axiom = all(A,imp(burger(A),not(qpwc(A)))).

lexicalKnowledge(restaurant,1,Axiom):- 
   Axiom = all(A,imp(restaurant(A),not(hashbar(A)))).

lexicalKnowledge(gun,1,Axiom):- 
   Axiom = all(A,imp(gun(A),not(sword(A)))).

lexicalKnowledge(wife,1,Axiom):- 
   Axiom = all(A,imp(wife(A),married(A))).


/*========================================================================
   Axioms for Lexical Knowledge: Proper Names
========================================================================*/

lexicalKnowledge(mia,0,Axiom):- 
   Axiom = all(A,imp(eq(A,mia),woman(A))).

lexicalKnowledge(vincent,0,Axiom):- 
   Axiom = all(A,imp(eq(A,vincent),man(A))).


/*========================================================================
   Axioms for Lexical Knowledge: Adjectives
========================================================================*/

lexicalKnowledge(red,1,Axiom):- 
   Axiom = all(A,imp(red(A),not(blue(A)))).

lexicalKnowledge(big,1,Axiom):- 
   Axiom = all(A,imp(big(A),not(small(A)))).

lexicalKnowledge(sad,1,Axiom):- 
   Axiom = all(A,imp(sad(A),not(happy(A)))).


/*========================================================================
   Axioms for Lexical Knowledge: Intransitive Verbs
========================================================================*/

lexicalKnowledge(collapse,1,Axiom):-
   Axiom = all(X,imp(collapse(X),or(person(X),building(X)))).

lexicalKnowledge(dance,1,Axiom):- 
   Axiom = all(X,imp(dance(X),person(X))).

lexicalKnowledge(die,1,Axiom):- 
   Axiom = all(X,imp(die(X),organism(X))).

lexicalKnowledge(growl,1,Axiom):- 
   Axiom = all(X,imp(growl(X),or(animal(X),person(X)))).


/*========================================================================
   Axioms for Lexical Knowledge: Transitive Verbs
========================================================================*/

lexicalKnowledge(clean,2,Axiom):- 
   Axiom = all(X,all(Y,imp(clean(X,Y),and(person(X),artifact(Y))))).

lexicalKnowledge(drink,2,Axiom):-    
   Axiom = all(X,all(Y,imp(drink(X,Y),and(person(X),beverage(Y))))).

lexicalKnowledge(eat,2,Axiom):- 
   Axiom = all(X,all(Y,imp(eat(X,Y),
               and(or(person(X),animal(X)),
                   and(edible(Y),food(Y)))))).


/*************************************************************************

    File: menu.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/



book1:-

   format('~n~`*t~70|~n', []),
   format('*~t*~70|~n', []),
   format('*~t Representation and Inference for Natural Language ~t*~70|~n',[]),
   format('*~t A First Course in Computational Semantics ~t*~70|~n',[]),
   format('*~t*~70|~n', []),
   format('*~t By Patrick Blackburn & Johan Bos ~t*~70|~n',[]),
   format('*~t*~70|~n', []),
   format('~`*t~70|~n', []),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <1> Chapter 1: First-Order Logic']),
   format('* ~a ~t*~70|~n', [' <2> Chapter 2: Lambda Calculus']),
   format('* ~a ~t*~70|~n', [' <3> Chapter 3: Underspecified Representations']),
   format('* ~a ~t*~70|~n', [' <4> Chapter 4: Propositional Inference']),
   format('* ~a ~t*~70|~n', [' <5> Chapter 5: First-Order Inference']),
   format('* ~a ~t*~70|~n', [' <6> Chapter 6: Putting Everything Together']),
   format('*~t*~70|~n', []),
   format('~`*t~70|~n', []),
   format('Enter your choice (1-6) and hit <Return>~n',[]).


chapter1:-

   format('~n~`*t Chapter 1: First-Order Logic ~`*t~70|~n',[]),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <1> Model Checker 1']),
   format('* ~a ~t*~70|~n', [' <2> Model Checker 2']),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <0> Main Menu']),
   format('*~t*~70|~n', []),
   format('~`*t~70|~n', []),
   format('Enter your choice (1-2) and hit <Return>~n',[]).

chapter2:-

   format('~n~`*t Chapter 2: Lambda Calculus ~`*t~70|~n',[]),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <1> Experiment 1 (experiment1.pl)']),
   format('* ~a ~t*~70|~n', [' <2> Experiment 2 (experiment2.pl)']),
   format('* ~a ~t*~70|~n', [' <3> Experiment 3 (experiment3.pl)']),
   format('* ~a ~t*~70|~n', [' <4> Beta Conversion (betaConversion.pl)']),
   format('* ~a ~t*~70|~n', [' <5> Lambda Calculus (lambda.pl)']),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <0> Main Menu']),
   format('*~t*~70|~n', []),
   format('~`*t~70|~n', []),
   format('Enter your choice (1-5) and hit <Return>~n',[]).

chapter3:-

   format('~n~`*t Chapter 3: Underspecified Representations ~`*t~70|~n',[]),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <1> Cooper Storage (cooperStorage.pl)']),
   format('* ~a ~t*~70|~n', [' <2> Keller Storage (kellerStorage.pl)']),
   format('* ~a ~t*~70|~n', [' <3> Hole Semantics (holeSemantics.pl)']),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <0> Main Menu']),
   format('*~t*~70|~n', []),
   format('~`*t~70|~n', []),
   format('Enter your choice (1-3) and hit <Return>~n',[]).

chapter4:-

   format('~n~`*t Chapter 4: Propositional Inference ~`*t~70|~n',[]),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <1> Propositional Tableau (propTableau.pl)']),
   format('* ~a ~t*~70|~n', [' <2> Propositional Resolution (propResolution.pl)']),
   format('* ~a ~t*~70|~n', [' <3> Conjunctive Normal Form (cnf.pl)']),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <0> Main Menu']),
   format('*~t*~70|~n', []),
   format('~`*t~70|~n', []),
   format('Enter your choice (1-3) and hit <Return>~n',[]).

chapter5:-

   format('~n~`*t Chapter 5: First-Order Inference ~`*t~70|~n',[]),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <1> Free-Variable Tableau (freeVarTabl.pl)']),
   format('* ~a ~t*~70|~n', [' <2> First-Order Resolution (foResolution.pl)']),
   format('* ~a ~t*~70|~n', [' <3> Theorem Provers and Model Builders (callInference.pl)']),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <0> Main Menu']),
   format('*~t*~70|~n', []),
   format('~`*t~70|~n', []),
   format('Enter your choice (1-3) and hit <Return>~n',[]).

chapter6:-

   format('~n~`*t Chapter 6: Putting Everything Together ~`*t~70|~n',[]),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <1> Baby Curt (babyCurt.pl)']),
   format('* ~a ~t*~70|~n', [' <2> Rugrat Curt (rugratCurt.pl)']),
   format('* ~a ~t*~70|~n', [' <3> Clever Curt (cleverCurt.pl)']),
   format('* ~a ~t*~70|~n', [' <4> Sensitive Curt (sensitiveCurt.pl)']),
   format('* ~a ~t*~70|~n', [' <5> Scrupulous Curt (scrupulousCurt.pl)']),
   format('* ~a ~t*~70|~n', [' <6> Knowledgeable Curt (knowledgeableCurt.pl)']),
   format('* ~a ~t*~70|~n', [' <7> Helpful Curt (helpfulCurt.pl)']),
   format('*~t*~70|~n', []),
   format('* ~a ~t*~70|~n', [' <0> Main Menu']),
   format('*~t*~70|~n', []),
   format('~`*t~70|~n', []),
   format('Enter your choice (1-7) and hit <Return>~n',[]).



menu:-
   book1,
   getChar(X),
   ( X=1, !, loop1(S), loop(S)
   ; X=2, !, loop2(S), loop(S)
   ; X=3, !, loop3(S), loop(S)
   ; X=4, !, loop4(S), loop(S)
   ; X=5, !, loop5(S), loop(S)
   ; X=6, !, loop6(S), loop(S)
   ; menu ).

loop(S):-
   ( S=run, !, menu
   ; S=quit, ! ).

loop1(S):-
   chapter1,
   getChar(X),
   ( X=1, !, S=quit, [modelChecker1]
   ; X=2, !, S=quit, [modelChecker2]
   ; S=run ).

loop2(S):-
   chapter2,
   getChar(X),
   ( X=1, !, S=quit, [experiment1]
   ; X=2, !, S=quit, [experiment2]
   ; X=3, !, S=quit, [experiment3]
   ; X=4, !, S=quit, [betaConversion]
   ; X=5, !, S=quit, [lambda]
   ; S=run ).

loop3(S):-
   chapter3,
   getChar(X),
   ( X=1, !, S=quit, [cooperStorage]
   ; X=2, !, S=quit, [kellerStorage]
   ; X=3, !, S=quit, [holeSemantics]
   ; S=run ).

loop4(S):-
   chapter4,
   getChar(X),
   ( X=1, !, S=quit, [propTableau]
   ; X=2, !, S=quit, [propResolution]
   ; X=3, !, S=quit, [cnf]
   ; S=run ).

loop5(S):-
   chapter5,
   getChar(X),
   ( X=1, !, S=quit, [freeVarTabl]
   ; X=2, !, S=quit, [foResolution]
   ; X=3, !, S=quit, [callInference]
   ; S=run ).

loop6(S):-
   chapter6,
   getChar(X),
   ( X=1, !, S=quit, [babyCurt]
   ; X=2, !, S=quit, [rugratCurt]
   ; X=3, !, S=quit, [cleverCurt]
   ; X=4, !, S=quit, [sensitiveCurt]
   ; X=5, !, S=quit, [scrupulousCurt]
   ; X=6, !, S=quit, [knowledgeableCurt]
   ; X=7, !, S=quit, [helpfulCurt]
   ; S=run ).

getChar(Y):-
   get0(X),
   ( X=10, !, getChar(Y)
   ; name(Y,[X]), peek ).

peek:-
   peek_code(X),
   ( X=10, !, get0(_)
   ; get0(_), peek ).


:- menu.


/*************************************************************************

    File: modelChecker1.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(modelChecker1,[modelCheckerTestSuite/0,
                         info/0,
                         infix/0,
                         prefix/0,
			 evaluate/2,
			 evaluate/3,
			 satisfy/4]).

:- use_module(comsemPredicates,[memberList/2,
                                compose/3,
                                infix/0,
                                prefix/0,
                                printRepresentations/1]).

:- use_module(exampleModels,[example/2]).

:- use_module(modelCheckerTestSuite,[test/4]).


/*========================================================================
   Evaluate a formula in an example model
========================================================================*/

evaluate(Formula,Example):-
   evaluate(Formula,Example,[]).


/*========================================================================
   Evaluate a formula in an example model wrt an assignment
========================================================================*/

evaluate(Formula,Example,Assignment):-
   example(Example,Model),
   satisfy(Formula,Model,Assignment,Result),
   printStatus(Result).
   

/*========================================================================
   Test Suite
========================================================================*/

modelCheckerTestSuite:-
   format('~n>>>>> MODEL CHECKER 1 ON TEST SUITE <<<<<~n',[]),
   test(Formula,Example,Assignment,Status),
   format('~n~nInput formula:',[]),
   printRepresentations([Formula]),
   format('Example Model: ~p~nStatus: ',[Example]),
   printStatus(Status),
   format('~nModel Checker says: ',[]),
   evaluate(Formula,Example,Assignment),
   fail.

modelCheckerTestSuite.


/*========================================================================
   Print status of a testsuite example
========================================================================*/

printStatus(pos):- write('Satisfied in model. ').
printStatus(neg):- write('Not satisfied in model. ').
printStatus(undef):- write('Cannot be evaluated. ').


/*========================================================================
   Existential Quantification
========================================================================*/

satisfy(some(X,Formula),model(D,F),G,pos):-
   memberList(V,D),
   satisfy(Formula,model(D,F),[g(X,V)|G],pos).

satisfy(some(X,Formula),model(D,F),G,neg):-
   setof(V,(memberList(V,D),satisfy(Formula,model(D,F),[g(X,V)|G],neg)),Dom),
   setof(V,memberList(V,D),Dom).
   

/*========================================================================
   Universal Quantification
========================================================================*/

satisfy(all(X,Formula),Model,G,Pol):-
   satisfy(not(some(X,not(Formula))),Model,G,Pol).


/*========================================================================
   Conjunction
========================================================================*/

satisfy(and(Formula1,Formula2),Model,G,pos):-
   satisfy(Formula1,Model,G,pos),
   satisfy(Formula2,Model,G,pos).

satisfy(and(Formula1,Formula2),Model,G,neg):-
   satisfy(Formula1,Model,G,neg);
   satisfy(Formula2,Model,G,neg).


/*========================================================================
   Disjunction
========================================================================*/

satisfy(or(Formula1,Formula2),Model,G,pos):-
   satisfy(Formula1,Model,G,pos);
   satisfy(Formula2,Model,G,pos).

satisfy(or(Formula1,Formula2),Model,G,neg):-
   satisfy(Formula1,Model,G,neg),
   satisfy(Formula2,Model,G,neg).


/*========================================================================
   Implication
========================================================================*/

satisfy(imp(Formula1,Formula2),Model,G,Pol):-
   satisfy(or(not(Formula1),Formula2),Model,G,Pol).


/*========================================================================
   Negation
========================================================================*/

satisfy(not(Formula),Model,G,pos):-
   satisfy(Formula,Model,G,neg).

satisfy(not(Formula),Model,G,neg):-
   satisfy(Formula,Model,G,pos).


/*========================================================================
   Equality
========================================================================*/

satisfy(eq(X,Y),Model,G,pos):-
   i(X,Model,G,Value1),
   i(Y,Model,G,Value2),
   Value1=Value2.

satisfy(eq(X,Y),Model,G,neg):-
   i(X,Model,G,Value1),
   i(Y,Model,G,Value2),
   \+ Value1=Value2.


/*========================================================================
   One-place predicates
========================================================================*/

satisfy(Formula,model(D,F),G,pos):-
   compose(Formula,Symbol,[Argument]),
   i(Argument,model(D,F),G,Value),
   memberList(f(1,Symbol,Values),F),
   memberList(Value,Values).

satisfy(Formula,model(D,F),G,neg):-
   compose(Formula,Symbol,[Argument]),
   i(Argument,model(D,F),G,Value),
   memberList(f(1,Symbol,Values),F),
   \+ memberList(Value,Values).


/*========================================================================
   Two-place predicates
========================================================================*/

satisfy(Formula,model(D,F),G,pos):-
   compose(Formula,Symbol,[Arg1,Arg2]),
   i(Arg1,model(D,F),G,Value1),
   i(Arg2,model(D,F),G,Value2),
   memberList(f(2,Symbol,Values),F),
   memberList((Value1,Value2),Values).

satisfy(Formula,model(D,F),G,neg):-
   compose(Formula,Symbol,[Arg1,Arg2]),
   i(Arg1,model(D,F),G,Value1),
   i(Arg2,model(D,F),G,Value2),
   memberList(f(2,Symbol,Values),F),
   \+ memberList((Value1,Value2),Values).


/*========================================================================
   Interpretation of Constants and Variables
========================================================================*/

i(X,model(_,F),G,Value):-
   (
       var(X),
       memberList(g(Y,Value),G),
       Y==X, ! % IMPORTANT CUT!
   ;
       atom(X),
       memberList(f(0,X,Value),F)
   ).
   

/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------------- <',[]),
   format('~n> modelChecker1.pl, by Patrick Blackburn and Johan Bos                      <',[]),
   format('~n>                                                                           <',[]),
   format('~n> ?- evaluate(F,E).          - evaluate a formula in a model                <',[]),
   format('~n> ?- evaluate(F,E,A).        - evaluate a formula in a model wrt assignment <',[]),
   format('~n> ?- modelCheckerTestSuite.  - run the test suite                           <',[]),
   format('~n> ?- infix.                  - switch to infix printing mode                <',[]),
   format('~n> ?- prefix.                 - switch to prefix printing mode               <',[]),
   format('~n> ?- info.                   - prints this information                      <',[]),
   format('~n> ------------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: modelChecker2.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(modelChecker2,[modelCheckerTestSuite/0,
                         info/0,
                         infix/0,
                         prefix/0,
			 evaluate/2,
			 evaluate/3,
			 satisfy/4]).

:- use_module(comsemPredicates,[memberList/2,
                                compose/3, 
                                proveOnce/1,
                                infix/0,
                                prefix/0,
                                printRepresentations/1]).

:- use_module(exampleModels,[example/2]).

:- use_module(modelCheckerTestSuite,[test/4]).


/*========================================================================
   Evaluate a formula in an example model
========================================================================*/

evaluate(Formula,Example):-
   evaluate(Formula,Example,[]).


/*========================================================================
   Evaluate a formula in an example model wrt an assignment
========================================================================*/

evaluate(Formula,Example,Assignment):-
   example(Example,Model),
   satisfy(Formula,Model,Assignment,Result),
   printStatus(Result).
   

/*========================================================================
   Test Suite
========================================================================*/

modelCheckerTestSuite:-
   format('~n>>>>> MODEL CHECKER 2 ON TEST SUITE <<<<<~n~n',[]),
   test(Formula,Example,Assignment,Status),
   format('~n~nInput formula:',[]),
   printRepresentations([Formula]),
   format('Example Model: ~p~nStatus: ',[Example]),
   printStatus(Status),
   example(Example,Model),
   proveOnce(modelChecker2:satisfy(Formula,Model,Assignment,Result)),
   format('~nModel Checker says: ',[]),
   printStatus(Result),
   printComparison(Status,Result),
   fail.

modelCheckerTestSuite.


/*========================================================================
   Print status of a testsuite example
========================================================================*/

printStatus(pos):- write('Satisfied in model. ').
printStatus(neg):- write('Not satisfied in model. ').
printStatus(undef):- write('Cannot be evaluated. ').


/*========================================================================
   Print comparison of result and expected result
========================================================================*/

printComparison(Expected,Result):-
	\+ Expected=Result,
	write('UNEXPECTED RESULT!').

printComparison(Expected,Result):-
	Expected=Result,
	write('OK!').


/*========================================================================
   Variables or Atoms
========================================================================*/

satisfy(X,_,_,undef):-
   var(X), !.

satisfy(X,_,_,undef):-
   atomic(X), !.


/*========================================================================
   Existential Quantification
========================================================================*/

satisfy(Formula,model(D,F),G,pos):-
   nonvar(Formula),
   Formula = some(X,SubFormula),
   var(X),
   memberList(V,D),
   satisfy(SubFormula,model(D,F),[g(X,V)|G],pos).

satisfy(Formula,model(D,F),G,neg):-
   nonvar(Formula),
   Formula = some(X,SubFormula),
   var(X),
   setof(V,memberList(V,D),All),
   setof(V,
         (
          memberList(V,D),
          satisfy(SubFormula,model(D,F),[g(X,V)|G],neg)
         ),
         All).

satisfy(Formula,model(D,F),G,undef):- 
   nonvar(Formula),
   Formula = some(X,SubFormula),
   (
    nonvar(X)
   ;
    var(X),
    memberList(V,D), 
    satisfy(SubFormula,model(D,F),[g(X,V)|G],undef)
   ). 


/*========================================================================
   Universal Quantification
========================================================================*/

satisfy(Formula,Model,G,Polarity):- 
   nonvar(Formula),
   Formula = all(X,SubFormula),
   satisfy(not(some(X,not(SubFormula))),Model,G,Polarity).


/*========================================================================
   Conjunction
========================================================================*/

satisfy(Formula,Model,G,pos):- 
   nonvar(Formula),
   Formula = and(Formula1,Formula2),
   satisfy(Formula1,Model,G,pos),
   satisfy(Formula2,Model,G,pos).

satisfy(Formula,Model,G,neg):- 
   nonvar(Formula),
   Formula = and(Formula1,Formula2),
   satisfy(Formula1,Model,G,pos),
   satisfy(Formula2,Model,G,neg).

satisfy(Formula,Model,G,neg):- 
   nonvar(Formula),
   Formula = and(Formula1,Formula2),
   satisfy(Formula1,Model,G,neg),
   satisfy(Formula2,Model,G,pos).

satisfy(Formula,Model,G,neg):- 
   nonvar(Formula),
   Formula = and(Formula1,Formula2),
   satisfy(Formula1,Model,G,neg),
   satisfy(Formula2,Model,G,neg).

satisfy(Formula,Model,G,undef):- 
   nonvar(Formula),
   Formula = and(Formula1,Formula2),
   (
    satisfy(Formula1,Model,G,undef)
   ;
    satisfy(Formula2,Model,G,undef)
   ).


/*========================================================================
   Disjunction
========================================================================*/

satisfy(Formula,Model,G,pos):- 
   nonvar(Formula),
   Formula = or(Formula1,Formula2),
   satisfy(Formula1,Model,G,pos),
   satisfy(Formula2,Model,G,pos).

satisfy(Formula,Model,G,pos):- 
   nonvar(Formula),
   Formula = or(Formula1,Formula2),
   satisfy(Formula1,Model,G,pos),
   satisfy(Formula2,Model,G,neg).

satisfy(Formula,Model,G,pos):- 
   nonvar(Formula),
   Formula = or(Formula1,Formula2),
   satisfy(Formula1,Model,G,neg),
   satisfy(Formula2,Model,G,pos).

satisfy(Formula,Model,G,neg):- 
   nonvar(Formula),
   Formula = or(Formula1,Formula2),
   satisfy(Formula1,Model,G,neg),
   satisfy(Formula2,Model,G,neg).

satisfy(Formula,Model,G,undef):-
   nonvar(Formula),
   Formula = or(Formula1,Formula2),
   (
    satisfy(Formula1,Model,G,undef)
   ;
    satisfy(Formula2,Model,G,undef)
   ).


/*========================================================================
   Implication
========================================================================*/

satisfy(Formula,Model,G,Polarity):- 
   nonvar(Formula),
   Formula = imp(Formula1,Formula2),
   satisfy(or(not(Formula1),Formula2),Model,G,Polarity).


/*========================================================================
   Negation
========================================================================*/

satisfy(Formula,Model,G,pos):- 
   nonvar(Formula),
   Formula = not(SubFormula),
   satisfy(SubFormula,Model,G,neg).

satisfy(Formula,Model,G,neg):- 
   nonvar(Formula),
   Formula = not(SubFormula),
   satisfy(SubFormula,Model,G,pos).

satisfy(Formula,Model,G,undef):- 
   nonvar(Formula),
   Formula = not(SubFormula),
   satisfy(SubFormula,Model,G,undef).


/*========================================================================
   Equality
========================================================================*/

satisfy(Formula,Model,G,pos):- 
   nonvar(Formula),
   Formula = eq(X,Y),
   i(X,Model,G,Value1),
   i(Y,Model,G,Value2),
   Value1=Value2.

satisfy(Formula,Model,G,neg):- 
   nonvar(Formula),
   Formula = eq(X,Y),
   i(X,Model,G,Value1),
   i(Y,Model,G,Value2),
   \+ Value1=Value2.

satisfy(Formula,Model,G,undef):-
   nonvar(Formula),
   Formula = eq(X,Y),
   (
    \+ i(X,Model,G,_)
   ;
    \+ i(Y,Model,G,_)
   ).


/*========================================================================
   One-place predicates
========================================================================*/

satisfy(Formula,model(D,F),G,pos):-
   nonvar(Formula),
   compose(Formula,Symbol,[Argument]),
   \+ Symbol = not,
   i(Argument,model(D,F),G,Value), 
   memberList(f(1,Symbol,Values),F), 
   memberList(Value,Values).

satisfy(Formula,model(D,F),G,neg):-
   nonvar(Formula),
   compose(Formula,Symbol,[Argument]),
   \+ Symbol = not,
   i(Argument,model(D,F),G,Value), 
   memberList(f(1,Symbol,Values),F), 
   \+ memberList(Value,Values).

satisfy(Formula,model(D,F),G,undef):-
   nonvar(Formula),
   compose(Formula,Symbol,[Argument]),
   \+ Symbol = not,
   (
    \+ var(Argument), 
    \+ atom(Argument)
   ; 
    var(Argument),
    \+ i(Argument,model(D,F),G,_)
   ;
    atom(Argument),
    \+ i(Argument,model(D,F),G,_)
   ;
    \+ memberList(f(1,Symbol,_),F)
   ).


/*========================================================================
   Two-place predicates
========================================================================*/

satisfy(Formula,model(D,F),G,pos):-
   nonvar(Formula),
   compose(Formula,Symbol,[Arg1,Arg2]),
   \+ memberList(Symbol,[eq,imp,or,and,some,all]),
   i(Arg1,model(D,F),G,Value1),
   i(Arg2,model(D,F),G,Value2), 
   memberList(f(2,Symbol,Values),F), 
   memberList((Value1,Value2),Values).

satisfy(Formula,model(D,F),G,neg):-
   nonvar(Formula),
   compose(Formula,Symbol,[Arg1,Arg2]),
   \+ memberList(Symbol,[eq,imp,or,and,some,all]),
   i(Arg1,model(D,F),G,Value1),
   i(Arg2,model(D,F),G,Value2), 
   memberList(f(2,Symbol,Values),F), 
   \+ memberList((Value1,Value2),Values).

satisfy(Formula,model(D,F),G,undef):-
   nonvar(Formula),
   compose(Formula,Symbol,[Arg1,Arg2]),
   \+ memberList(Symbol,[eq,imp,or,and,some,all]),
   (
    \+ var(Arg1), 
    \+ atom(Arg1)
   ; 
    \+ var(Arg2), 
    \+ atom(Arg2)
   ; 
    var(Arg1),
    \+ i(Arg1,model(D,F),G,_)
   ; 
    var(Arg2),
    \+ i(Arg2,model(D,F),G,_)
   ;
    atom(Arg1),
    \+ i(Arg1,model(D,F),G,_)
   ;
    atom(Arg2),
    \+ i(Arg2,model(D,F),G,_)
   ;
    \+ memberList(f(2,Symbol,_),F)
   ).


/*========================================================================
   Interpretation of Constants and Variables
========================================================================*/

i(X,model(D,F),G,Value):-
   (
    var(X),
    memberList(g(Y,Value),G), 
    X==Y, !,
    memberList(Value,D)
   ;
    atom(X),
    memberList(f(0,X,Value),F)
   ).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------------- <',[]),
   format('~n> modelChecker2.pl, by Patrick Blackburn and Johan Bos                      <',[]),
   format('~n>                                                                           <',[]),
   format('~n> ?- evaluate(F,E).          - evaluate a formula in a model                <',[]),
   format('~n> ?- evaluate(F,E,A).        - evaluate a formula in a model wrt assignment <',[]),
   format('~n> ?- modelCheckerTestSuite.  - run the test suite                           <',[]),  
   format('~n> ?- infix.                  - switch to infix printing mode                <',[]),
   format('~n> ?- prefix.                 - switch to prefix printing mode               <',[]),
   format('~n> ?- info.                   - print this information                       <',[]),
   format('~n> ------------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: modelCheckerTestSuite.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(modelCheckerTestSuite,[test/4]).


/*========================================================================
   Check given formula in given model with given assignment. 
   Correct answer recorded as fourth argument.
========================================================================*/

test(some(X,robber(X)),1,[],pos).

test(some(X,some(Y,love(X,Y))),1,[],pos).

test(some(X,some(Y,love(X,Y))),2,[],neg).

test(all(X,all(Y,love(X,Y))),2,[],neg).

test(not(all(X,all(Y,love(X,Y)))),2,[],pos).

test(all(X,all(Y,not(love(X,Y)))),2,[],pos).

test(eq(yolanda,honey_bunny),2,[],pos).

test(eq(mia,honey_bunny),2,[],undef).

test(not(eq(yolanda,honey_bunny)),2,[],neg).

test(not(eq(mia,honey_bunny)),2,[],undef).

test(all(X,or(robber(X),customer(X))),2,[],pos).

test(not(all(X,or(robber(X),customer(X)))),2,[],neg).

test(or(robber(X),customer(X)),2,[],undef).

test(or(robber(X),customer(X)),2,[g(X,d3)],pos).

test(some(X,and(man(X),some(X,woman(X)))),3,[],pos).

test(and(some(X,man(X)),some(X,woman(X))),3,[],pos).

test(not(some(X,woman(X))),3,[],neg).

test(some(X,and(tasty(X),burger(X))),3,[],undef).

test(not(some(X,and(tasty(X),burger(X)))),3,[],undef).

test(some(X,and(man(X),not(some(Y,woman(Y))))),3,[],neg).

test(some(X,and(man(X),not(some(X,woman(X))))),3,[],neg).

test(some(X,and(woman(X),not(some(X,customer(X))))),2,[],undef).



/*************************************************************************

    File: pluggingAlgorithm.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
     Module Declaration
========================================================================*/

:- module(pluggingAlgorithm,[plugUSR/2]).

:- use_module(comsemPredicates,[compose/3,
                                memberList/2,
                                selectFromList/3]).


/*========================================================================
     Declaration of dynamic predicates
========================================================================*/

:- dynamic plug/2, leq/2, hole/1, label/1.
:- dynamic some/3, all/3, que/4.
:- dynamic not/2, or/3, imp/3, and/3.
:- dynamic pred1/3, pred2/4, eq/3.


/*========================================================================
   Main Plugging Predicate (all pluggings)
========================================================================*/

plugUSR(USR,Sem):-
   numbervars(USR,0,_),          % 1 Skolemise USR
   initUSR, 
   assertUSR(USR),               % 2 Break down and assert USR
   top(Top),  
   findall(H,hole(H),Holes),
   findall(L,
           (label(L),\+ parent(_,L)),
           Labels),
   plugHoles(Holes,Labels,[]),   % 3 Calculate a plugging
   url2srl(Top,Sem).             % 4 Construct SRL formula


/*========================================================================
   Asserting immediate dominance relations to the Prolog database
========================================================================*/
    
parent(A,B):- imp(A,B,_).
parent(A,B):- imp(A,_,B).
parent(A,B):- or(A,B,_).
parent(A,B):- or(A,_,B).
parent(A,B):- and(A,B,_).
parent(A,B):- and(A,_,B).
parent(A,B):- not(A,B).
parent(A,B):- all(A,_,B).
parent(A,B):- some(A,_,B).
parent(A,B):- que(A,_,B,_).
parent(A,B):- que(A,_,_,B).
parent(A,B):- plug(A,B).


/*========================================================================
   Transitive Closure of Dominance
========================================================================*/

dom(X,Y):- dom([],X,Y).

dom(L,X,Y):- 
   parent(X,Y), 
   \+ memberList(parent(X,Y),L).

dom(L,X,Y):- 
   leq(Y,X), 
   \+ memberList(leq(Y,X),L).

dom(L,X,Z):- 
   parent(X,Y), 
   \+ memberList(parent(X,Y),L),
   dom([parent(X,Y)|L],Y,Z).

dom(L,X,Z):- 
   leq(Y,X), 
   \+ memberList(leq(Y,X),L),
   dom([leq(Y,X)|L],Y,Z).


/*========================================================================
   Plugging Holes with Labels
========================================================================*/

plugHoles([],_,Plugs):-
   admissiblePlugging(Plugs).

plugHoles([H|Holes],Labels1,Plugs):-
   admissiblePlugging(Plugs),
   selectFromList(L,Labels1,Labels2),
   plugHoles(Holes,Labels2,[plug(H,L)|Plugs]).


/*========================================================================
   Check whether plugging is propers
========================================================================*/

admissiblePlugging(Plugs):-
   retractall(plug(_,_)), 
   findall(X,(memberList(X,Plugs),assert(X)),_),
   \+ dom(A,A),
   \+ ( parent(A,B), parent(A,C), \+ B=C, dom(B,D), dom(C,D)).
   
 
/*========================================================================
    Top of a USR
========================================================================*/

top(X):- dom(X,_), \+ dom(_,X), !.


/*========================================================================
   From USRs to FOLs
========================================================================*/

url2srl(H,F):-
   hole(H),
   plug(H,L),
   url2srl(L,F).

url2srl(L,all(X,F)):-
   all(L,X,H),
   url2srl(H,F).

url2srl(L,some(X,F)):-
   some(L,X,H),
   url2srl(H,F).

url2srl(L,que(X,F1,F2)):-
   que(L,X,H1,H2),
   url2srl(H1,F1),
   url2srl(H2,F2).

url2srl(L,imp(F1,F2)):-
   imp(L,H1,H2),
   url2srl(H1,F1),
   url2srl(H2,F2).

url2srl(L,and(F1,F2)):-
   and(L,H1,H2),
   url2srl(H1,F1),
   url2srl(H2,F2).

url2srl(L,or(F1,F2)):-
   or(L,H1,H2),
   url2srl(H1,F1),
   url2srl(H2,F2).

url2srl(L,not(F)):-
   not(L,H),
   url2srl(H,F).

url2srl(L,eq(X,Y)):-
   eq(L,X,Y).

url2srl(L,F):-
   pred1(L,Symbol,Arg),
   compose(F,Symbol,[Arg]).

url2srl(L,F):-
   pred2(L,Symbol,Arg1,Arg2),
   compose(F,Symbol,[Arg1,Arg2]).


/*========================================================================
   Assert USR to Prolog database
========================================================================*/

assertUSR(some(_,F)):-   
    assertUSR(F).

assertUSR(and(F1,F2)):-
    assertUSR(F1),
    assertUSR(F2).

assertUSR(F):- 
    \+ F=and(_,_),
    \+ F=some(_,_),
    assert(F).


/*========================================================================
   Initialisation 
========================================================================*/

initUSR:-
   retractall(hole(_)), retractall(label(_)), retractall(leq(_,_)), 
   retractall(some(_,_,_)), retractall(all(_,_,_)), retractall(que(_,_,_,_)), 
   retractall(pred1(_,_,_)), retractall(pred2(_,_,_,_)), retractall(eq(_,_,_)), 
   retractall(and(_,_,_)), retractall(or(_,_,_)), retractall(not(_,_)), 
   retractall(plug(_,_)), retractall(imp(_,_,_)).



/*************************************************************************

    File: propResolution.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(propResolution,[info/0,
                          infix/0,
                          prefix/0, 
                          rprove/1,
                          rprove/2,
			  rproveTestSuite/0]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
				appendLists/3,
				unionSets/3,
				selectFromList/3]).

:- use_module(propTestSuite,[formula/2]).

:- use_module(cnf,[cnf/2]).


/*========================================================================
   Main Predicates
========================================================================*/

rprove(Formula):-
   cnf(not(Formula),CNF),
   refute(CNF).

rprove(Formula,Result):-
   (  
      rprove(Formula), !,
      Result='Theorem'
   ;
      Result='Not a theorem'
   ).
   

/*========================================================================
   Try all formulas from the test suite
========================================================================*/

rproveTestSuite:-
   format('~n~n>>>>> RESOLUTION PROVER ON TEST SUITE <<<<<~n',[]),
   formula(Formula,Status),
   format('~nInput formula: ~p~nStatus: ~p',[Formula,Status]),
   rprove(Formula,Result), 
   format('~nProver: ~p~n',[Result]),
   fail.

rproveTestSuite.


/*========================================================================
   Refute
========================================================================*/

refute(C):-
   memberList([],C).

refute(C):-
   \+ memberList([],C),
   resolveList(C,[],Output),
   unionSets(Output,C,NewC),
   \+ NewC = C, 
   refute(NewC).


/*========================================================================
    Resolve a list of clauses
========================================================================*/

resolveList([],Acc,Acc).

resolveList([Clause|List],Acc1,Acc3):-
   resolveClauseList(List,Clause,Acc1,Acc2),
   resolveList(List,Acc2,Acc3).


/*========================================================================
   Resolve a clause against a list
========================================================================*/

resolveClauseList([],_,Acc,Acc).

resolveClauseList([H|L],Clause,Acc1,Acc3):-
   resolve(Clause,H,Result), 
   unionSets([Result],Acc1,Acc2),
   resolveClauseList(L,Clause,Acc2,Acc3).

resolveClauseList([H|L],Clause,Acc1,Acc2):-
   \+ resolve(Clause,H,_),
   resolveClauseList(L,Clause,Acc1,Acc2).


/*========================================================================
   Resolve two clauses
========================================================================*/

resolve(Clause1,Clause2,NewClause):-
   selectFromList(Lit,Clause1,Temp1),
   selectFromList(not(Lit),Clause2,Temp2), 
   unionSets(Temp1,Temp2,NewClause).

resolve(Clause1,Clause2,NewClause):-
   selectFromList(not(Lit),Clause1,Temp1),
   selectFromList(Lit,Clause2,Temp2),
   unionSets(Temp1,Temp2,NewClause).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> -------------------------------------------------------------------- <',[]),
   format('~n> propResolution.pl, by Patrick Blackburn and Johan Bos                <',[]),
   format('~n>                                                                      <',[]),
   format('~n> ?- rprove(Formula).         - Succeeds if Formula is theorem         <',[]),
   format('~n> ?- rprove(Formula,Result).  - Try to prove Formula (always succeeds) <',[]),
   format('~n> ?- rproveTestSuite.         - Runs the test suite                    <',[]),
   format('~n> ?- infix.                   - switches to infix display mode         <',[]),
   format('~n> ?- prefix.                  - switches to prefix display mode        <',[]),
   format('~n> ?- info.                    - show this information                  <',[]),
   format('~n> -------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: propTableau.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(propTableau,[info/0,
                       infix/0,
                       prefix/0,
                       tprove/1,
		       tproveTestSuite/0]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
                                removeFirst/3]).

:- use_module(propTestSuite,[formula/2]).


/*========================================================================
   Main Predicate
========================================================================*/

tprove(F):-
   (
    closedTableau([[f(F)]]), !,
    write('Theorem.'), nl
   ;  
    write('Not a theorem.'), nl
   ).


/*========================================================================
   Prove all formulas from the testsuite
========================================================================*/

tproveTestSuite:-
   nl,write('>>>>> TABLEAU PROVER ON TESTSUITE <<<<< '),nl,
   formula(Formula,X),
   nl, 
   write('Input formula: '),print(Formula), nl,
   write('Status: '),write(X),nl,
   write('Prover says: '),tprove(Formula), nl,
   fail.

tproveTestSuite.


/*========================================================================
   General Tableau Predicates
========================================================================*/

closedTableau([]).

closedTableau(OldTableau):-
   expand(OldTableau,TempTableau),
   removeClosedBranches(TempTableau,NewTableau),
   closedTableau(NewTableau).


/*========================================================================
   Remove all closed branches
========================================================================*/

removeClosedBranches([],[]).

removeClosedBranches([Branch|Rest],Tableau):-
   closedBranch(Branch), !,
   removeClosedBranches(Rest,Tableau).

removeClosedBranches([Branch|Rest],[Branch|Tableau]):-
   removeClosedBranches(Rest,Tableau).

closedBranch(Branch):-
    memberList(t(X),Branch),
    memberList(f(X),Branch).


/*========================================================================
    Expand by applying tableau expansion rules
========================================================================*/

expand([Branch|Tableau],[NewBranch|Tableau]):-
   unaryExpansion(Branch,NewBranch), !.

expand([Branch|Tableau],[NewBranch|Tableau]):-
   conjunctiveExpansion(Branch,NewBranch), !.

expand([Branch|Tableau],[NewBranch1,NewBranch2|Tableau]):-
   disjunctiveExpansion(Branch,NewBranch1,NewBranch2), !.

expand([Branch|Rest],[Branch|Newrest]):-
   expand(Rest,Newrest).


/*========================================================================
    The tableau expansion rules
========================================================================*/

unaryExpansion(Branch,[Component|Temp]):-
   unary(SignedFormula,Component),
   removeFirst(SignedFormula,Branch,Temp).

conjunctiveExpansion(Branch,[Comp1,Comp2|Temp]):-
   conjunctive(SignedFormula,Comp1,Comp2),
   removeFirst(SignedFormula,Branch,Temp).

disjunctiveExpansion(Branch,[Comp1|Temp],[Comp2|Temp]):-
   disjunctive(SignedFormula,Comp1,Comp2),
   removeFirst(SignedFormula,Branch,Temp).


/*========================================================================
   Formula Identification
========================================================================*/

conjunctive(t(and(X,Y)),t(X),t(Y)).
conjunctive(f(or(X,Y)),f(X),f(Y)).
conjunctive(f(imp(X,Y)),t(X),f(Y)).

disjunctive(f(and(X,Y)),f(X),f(Y)).
disjunctive(t(or(X,Y)),t(X),t(Y)).
disjunctive(t(imp(X,Y)),f(X),t(Y)).

unary(t(not(X)),f(X)).
unary(f(not(X)),t(X)). 


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> propTableau.pl, by Patrick Blackburn and Johan Bos                  <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- tprove(Formula).   - Try to prove Formula                        <',[]),
   format('~n> ?- tproveTestSuite.   - runs the test suite for theorem proving     <',[]),
   format('~n> ?- infix.             - switches to infix display mode              <',[]),
   format('~n> ?- prefix.            - switches to prefix display mode             <',[]),
   format('~n> ?- info.              - show this information                       <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.


/*************************************************************************

    File: propTableau.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(propTableau,[info/0,
                       infix/0,
                       prefix/0,
                       tprove/1,
		       tproveTestSuite/0]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
                                removeFirst/3]).

:- use_module(propTestSuite,[formula/2]).


/*========================================================================
   Main Predicate
========================================================================*/

tprove(F):-
   (
    closedTableau([[f(F)]]), !,
    write('Theorem.'), nl
   ;  
    write('Not a theorem.'), nl
   ).


/*========================================================================
   Prove all formulas from the testsuite
========================================================================*/

tproveTestSuite:-
   nl,write('>>>>> TABLEAU PROVER ON TESTSUITE <<<<< '),nl,
   formula(Formula,X),
   nl, 
   write('Input formula: '),print(Formula), nl,
   write('Status: '),write(X),nl,
   write('Prover says: '),tprove(Formula), nl,
   fail.

tproveTestSuite.


/*========================================================================
   General Tableau Predicates
========================================================================*/

closedTableau([]).

closedTableau(OldTableau):-
   expand(OldTableau,TempTableau),
   removeClosedBranches(TempTableau,NewTableau),
   closedTableau(NewTableau).


/*========================================================================
   Remove all closed branches
========================================================================*/

removeClosedBranches([],[]).
/*
removeClosedBranches([Branch|Rest],Tableau):-
   closedBranch(Branch), !,
   removeClosedBranches(Rest,Tableau).

removeClosedBranches([Branch|Rest],[Branch|Tableau]):-
   removeClosedBranches(Rest,Tableau).
*/
removeClosedBranches([Branch|Rest],Tableau):-
	(
          closedBranch(Branch), !,
          removeClosedBranches(Rest,Tableau)
	;
	      Tableau=[Branch|TableauRest],
          removeClosedBranches(Rest,TableauRest)
	).

closedBranch(Branch):-
    memberList(t(X),Branch),
    memberList(f(X),Branch).


/*========================================================================
    Expand by applying tableau expansion rules
========================================================================*/

expand([Branch|Tableau],[NewBranch|Tableau]):-
   unaryExpansion(Branch,NewBranch), !.

expand([Branch|Tableau],[NewBranch|Tableau]):-
   conjunctiveExpansion(Branch,NewBranch), !.

expand([Branch|Tableau],[NewBranch1,NewBranch2|Tableau]):-
   disjunctiveExpansion(Branch,NewBranch1,NewBranch2), !.

expand([Branch|Rest],[Branch|Newrest]):-
   expand(Rest,Newrest).


/*========================================================================
    The tableau expansion rules
========================================================================*/

unaryExpansion(Branch,[Component|Temp]):-
   unary(SignedFormula,Component),
   removeFirst(SignedFormula,Branch,Temp).

conjunctiveExpansion(Branch,[Comp1,Comp2|Temp]):-
   conjunctive(SignedFormula,Comp1,Comp2),
   removeFirst(SignedFormula,Branch,Temp).

disjunctiveExpansion(Branch,[Comp1|Temp],[Comp2|Temp]):-
   disjunctive(SignedFormula,Comp1,Comp2),
   removeFirst(SignedFormula,Branch,Temp).


/*========================================================================
   Formula Identification
========================================================================*/

conjunctive(t(and(X,Y)),t(X),t(Y)).
conjunctive(f(or(X,Y)),f(X),f(Y)).
conjunctive(f(imp(X,Y)),t(X),f(Y)).

disjunctive(f(and(X,Y)),f(X),f(Y)).
disjunctive(t(or(X,Y)),t(X),t(Y)).
disjunctive(t(imp(X,Y)),f(X),t(Y)).

unary(t(not(X)),f(X)).
unary(f(not(X)),t(X)). 


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> propTableau.pl, by Patrick Blackburn and Johan Bos                  <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- tprove(Formula).   - Try to prove Formula                        <',[]),
   format('~n> ?- tproveTestSuite.   - runs the test suite for theorem proving     <',[]),
   format('~n> ?- infix.             - switches to infix display mode              <',[]),
   format('~n> ?- prefix.            - switches to prefix display mode             <',[]),
   format('~n> ?- info.              - show this information                       <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.


/*************************************************************************

    File: propTestSuite.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(propTestSuite,[formula/2]).


/*========================================================================
   Formulas
========================================================================*/

formula(imp(p, q), 'Not a theorem').

formula(imp(p, p), 'Theorem').

formula(imp(imp(imp(p,q),r),imp(imp(p,q),imp(p,r))), 'Theorem').

formula(imp(p,imp(q,p)), 'Theorem').

formula(imp(imp(p,q),imp(not(q),not(p))), 'Theorem').

formula(imp(imp(not(p),not(q)),imp(q,p)), 'Theorem').

formula(imp(not(not(p)),p), 'Theorem').

formula(imp(p,not(not(p))), 'Theorem').

formula(imp(not(not(not(not(p)))),p), 'Theorem').

formula(imp(p,not(not(not(not(p))))), 'Theorem').

formula(imp(not(or(p,q)),and(not(p),not(q))), 'Theorem').

formula(imp(and(not(p),not(q)),not(or(p,q))), 'Theorem').

formula(imp(not(and(p,q)),or(not(p),not(q))), 'Theorem').

formula(imp(and(not(p),not(q)),not(or(p,q))), 'Theorem').

formula(imp(or(r,and(p,q)),and(or(r,p),or(r,q))), 'Theorem').

formula(imp(and(or(r,p),or(r,q)),or(r,and(p,q))), 'Theorem').

formula(imp(and(r,or(p,q)),or(and(r,p),and(r,q))), 'Theorem').

formula(imp(or(and(r,p),and(r,q)),and(r,or(p,q))), 'Theorem').

formula(imp(and(imp(p,r),imp(q,s)),
            imp(and(p,q),and(r,s))), 'Theorem').

formula(imp(p,or(p,q)), 'Theorem').

formula(imp(p,or(q,p)), 'Theorem').

formula(imp(and(p,q),p), 'Theorem').

formula(imp(and(p,q),q), 'Theorem').

formula(imp(or(p,not(q)),or(p,q)), 'Not a theorem').

formula(imp(and(or(p,not(p)),or(p,not(q))),
            or(p,q)), 'Not a theorem').

formula(imp(and(and(or(p,not(p)),or(r,not(r))),or(p,not(q))),
            or(p,q)), 'Not a theorem').

formula(imp(or(p,and(not(p),q)),or(p,q)), 'Theorem').

formula(and(imp(or(p,and(not(p),q)),or(p,q)),
            imp(or(p,q),or(p,and(not(p),q)))), 'Theorem').


/*------------------------------------------------------------------------
     Pigeonehole principle with 3 pigeons and 2 pigeonholes. 
------------------------------------------------------------------------*/

formula(imp(and(and(or(p11,p12),or(p21,p22)),or(p31,p32)),
            or(or(or(or(or(and(p11,p21),and(p11,p31)),and(p21,p31)),
               and(p12,p22)),and(p12,p32)),and(p22,p32))), 'Theorem').


/*------------------------------------------------------------------------
     The following problem formula codes the pigeonehole principle
     with 4 pigeons and 3 pigeonholes. Neither the tableau nor
     resolution prover terminates on this example. For further
     discussion, see the last section of Chapter 4.
------------------------------------------------------------------------*/

formula(imp(and(and(and(or(or(p11,p12),p13),or(or(p21,p22),p23)),
            or(or(p31,p32),p33)),or(or(p41,p42),p43)),
               or(or(or(or(or(or(or(or(or(or(or(or(or(or(or(or(or(and(p11,p21),
                  and(p11,p31)),and(p11,p41)),and(p21,p31)),and(p21,p41)),
                      and(p31,p41)),and(p12,p22)),and(p12,p32)),and(p12,p42)),
                          and(p22,p32)),and(p22,p42)),and(p32,p42)),and(p13,p23)),
                              and(p13,p33)),and(p13,p43)),and(p23,p33)),
                                  and(p23,p43)),and(p33,p43))), 'Theorem').

formula(imp(and(or(or(or(p11,p12),p13),p14),
                and(or(or(or(p21,p22),p23),p24),
                    and(or(or(or(p31,p32),p33),p34),
                        and(or(or(or(p41,p42),p43),p44),
                            or(or(or(p51,p52),p53),p54))))),
            or(and(p11,p21),
               or(and(p11,p31),
                  or(and(p11,p41),
                     or(and(p11,p51),
                        or(and(p21,p31),
                           or(and(p21,p41),
                              or(and(p21,p51),
                                 or(and(p31,p41),
                                    or(and(p31,p41),
                                       or(and(p41,p51),
                                          or(and(p12,p22),
                                             or(and(p12,p32),
                                                or(and(p12,p42),
                                                   or(and(p12,p52),
                                                      or(and(p22,p32),
                                                         or(and(p22,p42),
                                                            or(and(p22,p52),
                                                               or(and(p32,p42),
                                                                  or(and(p32,p42),
                                                                     or(and(p42,p52),
                                                                        or(and(p13,p23),
                                                                           or(and(p13,p33),
                                                                              or(and(p13,p43),
                                                                                 or(and(p13,p53),
                                                                                    or(and(p23,p33),
                                                                                       or(and(p23,p43),
                                                                                          or(and(p23,p53),
                                                                                             or(and(p33,p43),
                                                                                                or(and(p33,p43),
                                                                                                   or(and(p43,p53),
                                                                                                      or(and(p14,p24),
                                                                                                         or(and(p14,p34),
                                                                                                            or(and(p14,p44),
                                                                                                               or(and(p14,p54),
                                                                                                                  or(and(p24,p34),
                                                                                                                     or(and(p24,p44),
                                                                                                                        or(and(p24,p54),
                                                                                                                           or(and(p34,p44),
                                                                                                                              or(and(p34,p44),
                                                                                                                                 or(and(p44,p54)))))))))))))))))))))))))))))))))))))))))), 'Theorem').


/*************************************************************************

    File: readLine.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(readLine,[readLine/1]).


/*========================================================================
   Output prompt, read from standard input and convert into list
========================================================================*/

readLine(WordList):-
   nl, write('> '),
   readWords(Words),
   checkWords(Words,WordList).


/*========================================================================
   Read in a sequence of characters, until a return is registered
========================================================================*/

readWords([Word|Rest]):-
   get0(Char),
   readWord(Char,Chars,State),
   name(Word,Chars),
   readRest(Rest,State).

readRest([],ended).

readRest(Rest,notended):-
   readWords(Rest).


/*========================================================================
   Read a word coded as Chars (a list of ascii values), starting 
   with with ascii value Char, and determine the State of input
   (`ended' = end of line, `notended' = not end of line).
   Blanks and full stops split words, a return ends a line.
========================================================================*/

readWord(32,[],notended):-!.     %%% blank

readWord(46,[],notended):-!.     %%% full stop

readWord(10,[],ended):-!.        %%% return

readWord(Code,[Code|Rest],State):-
   get0(Char),
   readWord(Char,Rest,State).


/*========================================================================
   Check if all words are unquoted atoms, if not convert them into atoms.
========================================================================*/

checkWords([],[]):- !.

checkWords([''|Rest1],Rest2):-
   checkWords(Rest1,Rest2).

checkWords([Atom|Rest1],[Atom2|Rest2]):-
   name(Atom,Word1),
   convertWord(Word1,Word2),
   name(Atom2,Word2),
   checkWords(Rest1,Rest2).


/*========================================================================
   Convert upper into lower case characters, and eliminate
   non-alphabetic characters.
========================================================================*/

convertWord([],[]):- !.

convertWord([Capital|Rest1],[Small|Rest2]):-
   Capital > 64, Capital < 91, !,
   Small is Capital + 32,
   convertWord(Rest1,Rest2).

convertWord([Number|Rest1],[Number|Rest2]):-
   Number > 47, Number < 58, !,
   convertWord(Rest1,Rest2).

convertWord([Weird|Rest1],Rest2):-
   (Weird < 97; Weird > 122), !,
   convertWord(Rest1,Rest2).

convertWord([Char|Rest1],[Char|Rest2]):-
   convertWord(Rest1,Rest2).


/*************************************************************************

    File: rugratCurt.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(curt,[curt/0,infix/0,prefix/0]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
                                appendLists/3,
				printRepresentations/1]).

:- use_module(kellerStorage,[kellerStorage/2]).

:- use_module(curtPredicates,[curtHelp/0,
                              curtOutput/1,
                              updateReadings/1,
                              updateHistory/1,
                              clearHistory/0,
                              selectReadings/3]).

:- use_module(foResolution,[rprove/1]).


/*========================================================================
   Dynamic Predicates
========================================================================*/

:- dynamic history/1, readings/1.

history([]).
readings([]).


/*========================================================================
   Start Curt
========================================================================*/

curt:- 
   curtTalk(run).


/*========================================================================
   Control
========================================================================*/

curtTalk(quit).

curtTalk(run):-
   readLine(Input),
   curtUpdate(Input,CurtsMoves,State), 
   curtOutput(CurtsMoves),
   curtTalk(State).


/*========================================================================
   Update Curt's Information State
========================================================================*/

curtUpdate([],[clarify],run):- !.

curtUpdate([bye],[bye],quit):- !,
   updateReadings([]),
   clearHistory.

curtUpdate([new],[],run):- !,
   updateReadings([]),
   clearHistory.

curtUpdate([help],[],run):- !,
   curtHelp.

curtUpdate([infix],[],run):- !,
   infix.

curtUpdate([prefix],[],run):- !,
   prefix.

curtUpdate([select,X],[],run):-
   number(X),
   readings(R1),
   selectReadings(X,R1,R2), !,
   updateReadings(R2).

curtUpdate([readings],[],run):- !,
   readings(R),
   printRepresentations(R).

curtUpdate([history],[],run):- !,
   history(H),
   printRepresentations(H).

curtUpdate(Input,Moves,run):-
   kellerStorage(Input,Readings), !,
   updateHistory(Input),
   consistentReadings(Readings,[]-ConsReadings),
   (
      ConsReadings=[],
      Moves=[contradiction]
   ;  
      \+ ConsReadings=[],
      Moves=[accept],
      combine(ConsReadings,CombinedReadings), 
      updateReadings(CombinedReadings)
   ).

curtUpdate(_,[noparse],run).


/*========================================================================
   Select Consistent Readings
========================================================================*/

consistentReadings([],C-C).

consistentReadings([New|Readings],C1-C2):-
   readings(Old),
   (
      consistent(Old,New), !,
      consistentReadings(Readings,[New|C1]-C2) 
   ;
      consistentReadings(Readings,C1-C2) 
   ).


/*========================================================================
   Consistency Checking calling Theorem Prover 
========================================================================*/

consistent([Old|_],New):-
   rprove(not(and(Old,New))), !,
   nl, write('Message (consistency checking): proof found.'),
   fail.

consistent([],New):-
   rprove(not(New)), !,
   nl, write('Message (consistency checking): proof found.'),
   fail.

consistent(_,_).

            
/*========================================================================
   Combine New Utterances with History
========================================================================*/

combine(New,New):- 
   readings([]).

combine(Readings,Updated):-
   readings([Old|_]),
   findall(and(Old,New),memberList(New,Readings),Updated).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n> rugratCurt.pl, by Patrick Blackburn and Johan Bos                   <',[]),
   format('~n>                                                                     <',[]),
   format('~n> ?- curt.                - start a dialogue with Curt                <',[]),
   format('~n>                                                                     <',[]),
   format('~n> Type "help" to get more information about features                  <',[]),
   format('~n> ------------------------------------------------------------------- <',[]),
   format('~n~n',[]).


/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: scrupulousCurt.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(curt,[curt/0,infix/0,prefix/0]).

:- use_module(callInference,[callTPandMB/6]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
				printRepresentations/1]).

:- use_module(kellerStorage,[kellerStorage/2]).

:- use_module(elimEquivReadings,[elimEquivReadings/2]).

:- use_module(curtPredicates,[curtHelp/0,
                              curtOutput/1,
                              updateReadings/1,
                              updateModels/1,
                              updateHistory/1,
                              clearHistory/0,
                              selectReadings/3]).


/*========================================================================
   Dynamic Predicates
========================================================================*/

:- dynamic history/1, readings/1, models/1.

history([]).
readings([]).
models([]).


/*========================================================================
   Start Curt
========================================================================*/

curt:- 
   curtTalk(run).


/*========================================================================
   Control
========================================================================*/

curtTalk(quit).

curtTalk(run):-
   readLine(Input),
   curtUpdate(Input,CurtsMoves,State), 
   curtOutput(CurtsMoves),
   curtTalk(State).


/*========================================================================
   Update Curt's Information State
========================================================================*/

curtUpdate([],[clarify],run):- !.

curtUpdate([bye],[bye],quit):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([new],[],run):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([infix],[],run):- !,
   infix.

curtUpdate([prefix],[],run):- !,
   prefix.

curtUpdate([help],[],run):- !,
   curtHelp.

curtUpdate([select,X],[],run):-
   number(X),
   readings(R1),
   selectReadings(X,R1,R2), !,
   updateReadings(R2),
   models(M1),
   selectReadings(X,M1,M2),
   updateModels(M2).

curtUpdate([summary],[],run):-
   readings(Readings),
   elimEquivReadings(Readings,Unique),
   updateReadings(Unique),
   updateModels([]).

curtUpdate([readings],[],run):- !,
   readings(R),
   printRepresentations(R).

curtUpdate([models],[],run):- !,
   models(M),
   printRepresentations(M).

curtUpdate([history],[],run):- !,
   history(H),
   printRepresentations(H).

curtUpdate(Input,Moves,run):-
   kellerStorage(Input,Readings), !,
   updateHistory(Input),
   consistentReadings(Readings,[]-ConsReadings,[]-Models),
   (
      ConsReadings=[],
      Moves=[contradiction]
   ;
      \+ ConsReadings=[],
      informativeReadings(ConsReadings,[]-InfReadings),   
      (
         InfReadings=[],
         Moves=[obvious]
      ;  
         \+ InfReadings=[],
         Moves=[accept]
      ),
      combine(ConsReadings,CombinedReadings), 
      updateReadings(CombinedReadings),
      updateModels(Models)
   ).

curtUpdate(_,[noparse],run).


/*========================================================================
   Combine New Utterances with History
========================================================================*/

combine(New,New):-
   readings([]).

combine(Readings,Updated):-
   readings([Old|_]),
   findall(and(Old,New),memberList(New,Readings),Updated).


/*========================================================================
   Select Consistent Readings
========================================================================*/

consistentReadings([],C-C,M-M).

consistentReadings([New|Readings],C1-C2,M1-M2):-
   readings(Old),
   (
      consistent(Old,New,Model), !,
      consistentReadings(Readings,[New|C1]-C2,[Model|M1]-M2) 
   ;
      consistentReadings(Readings,C1-C2,M1-M2) 
   ).


/*========================================================================
   Consistency Checking calling Theorem Prover and Model Builder
========================================================================*/

consistent([Old|_],New,Model):-
   DomainSize=15,
   callTPandMB(not(and(Old,New)),and(Old,New),DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).

consistent([],New,Model):-
   DomainSize=15,
   callTPandMB(not(New),New,DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
   Select Informative Readings
========================================================================*/

informativeReadings([],I-I).

informativeReadings([New|L],I1-I2):-
   readings(Old),
   (
      informative(Old,New), !,
      informativeReadings(L,[New|I1]-I2) 
   ;
      informativeReadings(L,I1-I2) 
   ).


/*========================================================================
   Informativity Checking calling Theorem Prover
========================================================================*/

informative([Old|_],New):-
   DomainSize=15,
   callTPandMB(not(and(Old,not(New))),and(Old,not(New)),DomainSize,Proof,Model,Engine),
   format('~nMessage (informativity checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).

informative([],New):-
   DomainSize=15,
   callTPandMB(New,not(New),DomainSize,Proof,Model,Engine),
   format('~nMessage (informativity checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n> sensitiveCurtFOL.pl, by Patrick Blackburn and Johan Bos    <',[]),
   format('~n>                                                            <',[]),
   format('~n> ?- curt.                - start a dialogue with Curt       <',[]),
   format('~n>                                                            <',[]),
   format('~n> Type "help" to get more information about features         <',[]),
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n~n',[]).



/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: semLexHole.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Semantic Macros
========================================================================*/

semLex(det,M):-
   M = [type:uni,
        sem:lam(N,lam(V,lam(H,lam(L,some(H1,some(L1,some(L2,some(L3,some(X,
                and(hole(H1),and(label(L1),and(label(L2),and(label(L3),
                    and(all(L2,X,L3),and(imp(L3,L1,H1),and(leq(L,H1),
                        and(leq(L2,H),and(app(app(app(N,X),H),L1),
                            app(app(app(V,X),H),L)))))))))))))))))))].

semLex(det,M):-
   M = [type:indef,
        sem:lam(N,lam(V,lam(H,lam(L,some(H1,some(L1,some(L2,some(L3,some(X,
                and(hole(H1),and(label(L1),and(label(L2),and(label(L3),
                    and(some(L2,X,L3),and(and(L3,L1,H1),and(leq(L,H1),
                        and(leq(L2,H),and(app(app(app(N,X),H),L1),
                            app(app(app(V,X),H),L)))))))))))))))))))].

semLex(det,M):-
   M = [type:wh,
        sem:lam(N,lam(V,lam(H,lam(L,some(H1,some(L1,some(L2,some(X,and(hole(H1),
                and(label(L1),and(label(L2),and(que(L2,X,L1,H1),and(leq(L,H1),
                    and(leq(L2,H),and(app(app(app(N,X),H),L1),
                        app(app(app(V,X),H),L))))))))))))))))].

semLex(pn,M):-
   M = [symbol:Sym,
        sem:lam(V,lam(H,lam(L,app(app(app(V,Sym),H),L))))].

semLex(noun,M):-
   M = [symbol:Sym,
        sem:lam(X,lam(H,lam(L,and(pred1(L,Sym,X),leq(L,H)))))].

semLex(iv,M):-
   M = [symbol:Sym,
        sem:lam(X,lam(H,lam(L,and(pred1(L,Sym,X),leq(L,H)))))].

semLex(tv,M):-
   M = [symbol:Sym,
        sem:lam(Z,lam(X,app(Z,lam(Y,lam(H,lam(L,and(pred2(L,Sym,X,Y),leq(L,H))))))))]. 

semLex(qnp,M):-
   M = [type:wh,
        symbol:Sym,
        sem:lam(V,lam(H,lam(L,some(H1,some(L2,some(L3,some(X,and(hole(H1),and(label(L2),
                and(label(L3),and(que(L2,X,L3,H1),and(pred1(L3,Sym,X),and(leq(L,H1),
                    and(leq(L2,H),app(app(app(V,X),H),L)))))))))))))))]. 

semLex(cop,M):-
    M = [pol:pos,
         sem:lam(Z,lam(X,app(Z,lam(Y,lam(H,lam(L,and(eq(L,Y,X),leq(L,H))))))))];
    M = [pol:neg,
         sem:lam(Z,lam(X,app(Z,lam(Y,lam(H,lam(L,some(L1,and(label(L1),some(H1,and(hole(H1),and(not(L1,H1),
                 and(eq(L,Y,X),and(leq(L,H1),leq(L1,H))))))))))))))].

semLex(relpro,M):-
   M = [sem:lam(V,lam(N,lam(X,lam(H,lam(L,some(H1,some(L1,some(L2,and(hole(H1),and(label(L1),
                and(label(L2),and(and(L,L1,H1),and(leq(L,H),and(leq(L2,H1),
                    and(app(app(app(V,X),H),L2),app(app(app(N,X),H),L1))))))))))))))))].

semLex(prep,M):-
   M = [symbol:Sym,
        sem:lam(Z,lam(N,lam(X,lam(H,lam(L,some(H2,some(L2,some(L3,and(hole(H2),and(label(L2),
                and(label(L3),and(and(L,L2,H2),and(leq(L,H),and(leq(L3,H2),and(app(app(app(Z,
                    lam(Y,lam(H1,lam(L1,and(pred2(L1,Sym,Y,X),leq(L1,H1)))))),H),L3),
                        app(app(app(N,X),H),L2))))))))))))))))].

semLex(adj,M):-
   M = [symbol:Sym,
        sem:lam(P,lam(X,lam(H,lam(L,some(L1,some(L2,and(label(L1),and(label(L2),and(and(L,L1,L2),
                and(pred1(L2,Sym,X),and(leq(L,H),app(app(app(P,X),H),L1))))))))))))].

semLex(av,M):-
   M = [pol:neg,
        sem:lam(V,lam(X,lam(H,lam(L,some(S,some(N,and(hole(S),and(label(N),and(not(N,S),
                and(leq(N,H),and(leq(L,S),app(app(app(V,X),H),L))))))))))))];
   M = [pol:pos,
        sem:lam(V,lam(X,lam(H,lam(L,app(app(app(V,X),H),L)))))]. 

semLex(coord,M):-
   M = [type:conj,
        sem:lam(C1,lam(C2,lam(X,lam(H,lam(L,some(L1,some(L2,and(label(L1),and(label(L2),
                and(and(L,L1,L2),and(leq(L,H),and(app(app(app(C1,X),H),L1),
                    app(app(app(C2,X),H),L2)))))))))))))];  
   M = [type:disj,
        sem:lam(C1,lam(C2,lam(X,lam(H,lam(L,some(L1,some(L2,and(label(L1),and(label(L2),
                and(and(L,L1,L2),and(leq(L,H),and(app(app(app(C1,X),H),L1),
                    app(app(app(C2,X),H),L2)))))))))))))].



/*************************************************************************

    File: semLexLambda.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

semLex(det,M):-
   M = [type:uni,
        sem:lam(U,lam(V,all(X,imp(app(U,X),app(V,X)))))].

semLex(det,M):-
   M = [type:indef,
        sem:lam(P,lam(Q,some(X,and(app(P,X),app(Q,X)))))].

semLex(det,M):-
   M = [type:wh,
        sem:lam(P,lam(Q,que(X,app(P,X),app(Q,X))))].

semLex(pn,M):-
   M = [symbol:Sym,
        sem:lam(P,app(P,Sym))].

semLex(noun,M):-
   M = [symbol:Sym,
        sem:lam(X,Formula)],
   compose(Formula,Sym,[X]).

semLex(iv,M):-
   M = [symbol:Sym,
        sem:lam(X,Formula)],
   compose(Formula,Sym,[X]).

semLex(tv,M):-
   M = [symbol:Sym,
        sem:lam(K,lam(Y,app(K,lam(X,Formula))))], 
   compose(Formula,Sym,[Y,X]).

semLex(qnp,M):-
   M = [type:wh,
        symbol:Sym,
        sem:lam(Q,que(X,Formula,app(Q,X)))], 
   compose(Formula,Sym,[X]).

semLex(cop,M):-
   M = [pol:pos,
        sem:lam(K,lam(Y,app(K,lam(X,eq(Y,X)))))];
   M = [pol:neg,
        sem:lam(K,lam(Y,not(app(K,lam(X,eq(Y,X))))))].

semLex(relpro,M):-
   M = [sem:lam(P,lam(Q,lam(X,and(app(P,X),app(Q,X)))))].

semLex(prep,M):-
   M = [symbol:Sym,
        sem:lam(K,lam(P,lam(Y,and(app(K,lam(X,F)),app(P,Y)))))],
   compose(F,Sym,[Y,X]).


semLex(adj,M):-
   M = [symbol:Sym,
        sem:lam(P,lam(X,and(F,app(P,X))))],
   compose(F,Sym,[X]).

semLex(av,M):-
   M = [pol:neg,
        sem:lam(P,lam(X,not(app(P,X))))];
   M = [pol:pos,
        sem:lam(P,lam(X,app(P,X)))].

semLex(coord,M):-
   M = [type:conj,
        sem:lam(X,lam(Y,lam(P,and(app(X,P),app(Y,P)))))];  
   M = [type:disj,
        sem:lam(X,lam(Y,lam(P,or(app(X,P),app(Y,P)))))].

semLex(prep,M):-
    M = [symbol:without,
         sem:lam(K,lam(P,lam(Y,not(and(app(K,lam(X,F)),app(P,Y))))))],
    NewSym = with,
    compose(F,NewSym,[Y,X]).


/*************************************************************************

    File: semLexStorage.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Semantic Macros
========================================================================*/

semLex(det,M):-
   M = [type:uni,
        sem:[lam(P,lam(Q,all(X,imp(app(P,X),app(Q,X)))))]].

semLex(det,M):-
   M = [type:indef,
        sem:[lam(P,lam(Q,some(X,and(app(P,X),app(Q,X)))))]].

semLex(det,M):-
   M = [type:wh,
        sem:[lam(P,lam(Q,que(X,app(P,X),app(Q,X))))]].

semLex(pn,M):-
   M = [symbol:Sym,
        sem:[lam(P,app(P,Sym))]].

semLex(noun,M):-
   M = [symbol:Sym,
        sem:[lam(X,Formula)]],
   compose(Formula,Sym,[X]).

semLex(iv,M):-
   M = [symbol:Sym,
        sem:[lam(X,Formula)]],
   compose(Formula,Sym,[X]).

semLex(tv,M):-
   M = [symbol:Sym,
        sem:[lam(K,lam(Y,app(K,lam(X,Formula))))]], 
   compose(Formula,Sym,[Y,X]).

semLex(qnp,M):-
   M = [type:wh,
        symbol:Sym,
        sem:[lam(Q,que(X,Formula,app(Q,X)))]], 
   compose(Formula,Sym,[X]).

semLex(cop,M):-
   M = [pol:pos,
        sem:[lam(K,lam(Y,app(K,lam(X,eq(Y,X)))))]];
   M = [pol:neg,
        sem:[lam(K,lam(Y,not(app(K,lam(X,eq(Y,X))))))]].

semLex(relpro,M):-
   M = [sem:[lam(P,lam(Q,lam(X,and(app(P,X),app(Q,X)))))]].

semLex(prep,M):-
   M = [symbol:Sym,
        sem:[lam(K,lam(P,lam(Y,and(app(K,lam(X,F)),app(P,Y)))))]],
   compose(F,Sym,[Y,X]).

semLex(adj,M):-
   M = [symbol:Sym,
        sem:[lam(P,lam(X,and(F,app(P,X))))]],
   compose(F,Sym,[X]).

semLex(av,M):-
   M = [pol:neg,
        sem:[lam(P,lam(X,not(app(P,X))))]];
   M = [pol:pos,
        sem:[lam(P,lam(X,app(P,X)))]].

semLex(coord,M):-
   M = [type:conj,
        sem:[lam(X,lam(Y,lam(P,and(app(X,P),app(Y,P)))))]];  
   M = [type:disj,
        sem:[lam(X,lam(Y,lam(P,or(app(X,P),app(Y,P)))))]].










/*************************************************************************

    File: semRulesCooper.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Semantic Rules
========================================================================*/

combine(t:Converted,[s:Sem]):- 
   betaConvert(Sem,Converted).

combine(t:Converted,[q:Sem]):- 
   betaConvert(Sem,Converted).

combine(s:app(A,B),[s:A,s:B]).
combine(s:lam(B,imp(S,B)),[if:S]).
combine(s:lam(B,or(S,B)),[either:S]).
combine(s:S,[then:S]).
combine(s:S,[or:S]).
combine(s:S,[np:[A|S1],vp:[B|S2]]):-
   appendLists(S1,S2,S3),
   sRetrieval([app(A,B)|S3],Retrieved),
   betaConvert(Retrieved,S).

combine(sinv:S,[av:[A],np:[B|S1],vp:[C|S2]]):-
   appendLists(S1,S2,S3),
   sRetrieval([app(B,app(A,C))|S3],Retrieved),
   betaConvert(Retrieved,S).
  
combine(q:Q,[whnp:[A|S1],vp:[B|S2]]):-
   sRetrieval([app(A,B)|S2],VP),
   sRetrieval([VP|S1],Retrieved),
   betaConvert(Retrieved,Q),
   Q=que(_,_,_).

combine(q:Q,[sinv:Q]):-
   Q=que(_,_,_).

combine(np:A,[pn:A]).
combine(np:A,[qnp:A]).
combine(np:[lam(P,app(P,X)),bo(app(A,B),X)|S],[det:[A],n:[B|S]]).
combine(np:[app(A,B)|S],[det:[A],n:[B|S]]).
combine(np:[app(app(B,A),C)|S3],[np:[A|S1],coord:[B],np:[C|S2]]):-
   appendLists(S1,S2,S3).

combine(whnp:[lam(P,app(P,X)),bo(app(A,B),X)|S],[det:[A],n:[B|S]]).
combine(whnp:[lam(P,app(P,X)),bo(A,X)],[qnp:[A]]).

combine(n:[app(A,B)|S],[adj:[A],n:[B|S]]).
combine(n:A,[noun:A]).
combine(n:[app(B,A)|S],[noun:[A],nmod:[B|S]]).
combine(n:[app(app(B,A),C)|S3],[n:[A|S1],coord:[B],n:[C|S2]]):-
   appendLists(S1,S2,S3).

combine(nmod:A,[pp:A]).
combine(nmod:A,[rc:A]).
combine(nmod:[lam(P,app(A,app(B,P)))|S3],[pp:[A|S1],nmod:[B|S2]]):-
   appendLists(S1,S2,S3).

combine(vp:[app(A,B)|S],[av:[A],vp:[B|S]]).
combine(vp:[app(A,B)|S],[cop:[A],np:[B|S]]).
combine(vp:A,[iv:A]).
combine(vp:[app(A,B)|S],[tv:[A],np:[B|S]]).
combine(vp:[app(app(B,A),C)|S3],[vp:[A|S1],coord:[B],vp:[C|S2]]):-
   appendLists(S1,S2,S3).

combine(pp:[app(A,B)|S],[prep:[A],np:[B|S]]).

combine(rc:[app(A,B)|S],[relpro:[A],vp:[B|S]]).


/*************************************************************************

    File: semRulesHole.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Semantic Rules
========================================================================*/

combine(t:U,[s:S]):- 
   betaConvert(some(T,and(hole(T),some(L,and(label(L),app(app(S,T),L))))),U).

combine(t:U,[q:S]):- 
   betaConvert(some(T,and(hole(T),some(L,and(label(L),app(app(S,T),L))))),U).

combine(s:app(A,B),[s:A,s:B]).
combine(s:S,[then:S]).
combine(s:S,[or:S]).
combine(s:app(A,B),[np:A,vp:B]).
combine(s:lam(B,lam(H,lam(L,U))),[if:S]):-
   U = some(H1,some(H2,some(L1,some(L2,and(hole(H1),and(hole(H2),and(label(L1),
          and(label(L2),and(imp(L,H1,H2),and(leq(L,H),and(app(app(S,H1),L1),
              app(app(B,H2),L2)))))))))))).
combine(s:lam(B,lam(H,lam(L,U))),[either:S]):-
   U = some(H1,some(H2,some(L1,some(L2,and(hole(H1),and(hole(H2),and(label(L1),
          and(label(L2),and(or(L,H1,H2),and(leq(L,H),and(app(app(S,H1),L1),
              app(app(B,H2),L2)))))))))))).

combine(sinv:app(B,app(A,C)),[av:A,np:B,vp:C]).
  
combine(q:app(A,B),[whnp:A,vp:B]).
combine(q:Q,[sinv:Q]).

combine(np:app(app(B,A),C),[np:A,coord:B,np:C]).
combine(np:app(A,B),[det:A,n:B]).
combine(np:A,[pn:A]).
combine(np:A,[qnp:A]).

combine(whnp:app(A,B),[det:A,n:B]).
combine(whnp:A,[qnp:A]).

combine(n:app(app(B,A),C),[n:A,coord:B,n:C]).
combine(n:app(A,B),[adj:A,n:B]).
combine(n:A,[noun:A]).
combine(n:app(B,A),[noun:A,nmod:B]).

combine(nmod:A,[pp:A]).
combine(nmod:A,[rc:A]).
combine(nmod:lam(P,app(A,app(B,P))),[pp:A,nmod:B]).

combine(vp:app(app(B,A),C),[vp:A,coord:B,vp:C]).
combine(vp:app(A,B),[av:A,vp:B]).
combine(vp:app(A,B),[cop:A,np:B]).
combine(vp:A,[iv:A]).
combine(vp:app(A,B),[tv:A,np:B]).

combine(pp:app(A,B),[prep:A,np:B]).

combine(rc:app(A,B),[relpro:A,vp:B]).



/*************************************************************************

    File: semRulesKeller.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Semantic Rules
========================================================================*/

combine(t:Converted,[s:Sem]):- 
   betaConvert(Sem,Converted).

combine(t:Converted,[q:Sem]):- 
   betaConvert(Sem,Converted).

combine(s:app(A,B),[s:A,s:B]).
combine(s:lam(B,imp(S,B)),[if:S]).
combine(s:lam(B,or(S,B)),[either:S]).
combine(s:S,[then:S]).
combine(s:S,[or:S]).
combine(s:S,[np:[A|S1],vp:[B|S2]]):-
   appendLists(S1,S2,S3),
   sRetrieval([app(A,B)|S3],Retrieved),
   betaConvert(Retrieved,S).

combine(sinv:S,[av:[A],np:[B|S1],vp:[C|S2]]):-
   appendLists(S1,S2,S3),
   sRetrieval([app(B,app(A,C))|S3],Retrieved),
   betaConvert(Retrieved,S).
  
combine(q:Q,[whnp:[A|S1],vp:[B|S2]]):-
   sRetrieval([app(A,B)|S2],VP),
   sRetrieval([VP|S1],Retrieved),
   betaConvert(Retrieved,Q).

combine(q:Q,[sinv:Q]):-
   Q=que(_,_,_).

combine(np:A,[pn:A]).
combine(np:A,[qnp:A]).
combine(np:[lam(P,app(P,X)),bo([app(A,B)|S],X)],[det:[A],n:[B|S]]).
combine(np:[app(A,B)|S],[det:[A],n:[B|S]]).
combine(np:[app(app(B,A),C)|S3],[np:[A|S1],coord:[B],np:[C|S2]]):-
   appendLists(S1,S2,S3).

combine(whnp:[lam(P,app(P,X)),bo([app(A,B)|S],X)],[det:[A],n:[B|S]]).
combine(whnp:[lam(P,app(P,X)),bo([A],X)],[qnp:[A]]).

combine(n:[app(A,B)|S],[adj:[A],n:[B|S]]).
combine(n:A,[noun:A]).
combine(n:[app(B,A)|S],[noun:[A],nmod:[B|S]]).
combine(n:[app(app(B,A),C)|S3],[n:[A|S1],coord:[B],n:[C|S2]]):-
	appendLists(S1,S2,S3).

combine(nmod:A,[pp:A]).
combine(nmod:A,[rc:A]).
combine(nmod:[lam(P,app(A,app(B,P)))|S3],[pp:[A|S1],nmod:[B|S2]]):-
   appendLists(S1,S2,S3).

combine(vp:[app(A,B)|S],[av:[A],vp:[B|S]]).
combine(vp:[app(A,B)|S],[cop:[A],np:[B|S]]).
combine(vp:A,[iv:A]).
combine(vp:[app(A,B)|S],[tv:[A],np:[B|S]]).
combine(vp:[app(app(B,A),C)|S3],[vp:[A|S1],coord:[B],vp:[C|S2]]):-
	appendLists(S1,S2,S3).

combine(pp:[app(A,B)|S],[prep:[A],np:[B|S]]).

combine(rc:[app(A,B)|S],[relpro:[A],vp:[B|S]]).



/*************************************************************************

    File: semRulesLambda.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

/*========================================================================
   Semantic Rules
========================================================================*/

combine(t:Converted,[s:Sem]):- 
   betaConvert(Sem,Converted).

combine(t:Converted,[q:Sem]):- 
   betaConvert(Sem,Converted).

combine(s:app(A,B),[np:A,vp:B]).
combine(s:app(A,B),[s:A,s:B]).
combine(s:lam(B,imp(S,B)),[if:S]).
combine(s:lam(B,or(S,B)),[either:S]).
combine(s:S,[then:S]).
combine(s:S,[or:S]).

combine(sinv:app(B,app(A,C)),[av:A,np:B,vp:C]).

combine(q:app(A,B),[whnp:A,vp:B]).
combine(q:A,[sinv:A]).

combine(np:app(app(B,A),C),[np:A,coord:B,np:C]).
combine(np:app(A,B),[det:A,n:B]).
combine(np:A,[pn:A]).
combine(np:A,[qnp:A]).

combine(whnp:app(A,B),[det:A,n:B]).
combine(whnp:A,[qnp:A]).

combine(n:app(app(B,A),C),[n:A,coord:B,n:C]).
combine(n:app(A,B),[adj:A,n:B]).
combine(n:A,[noun:A]).
combine(n:app(B,A),[noun:A,nmod:B]).

combine(nmod:A,[pp:A]).
combine(nmod:A,[rc:A]).
combine(nmod:lam(P,app(A,app(B,P))),[pp:A,nmod:B]).

combine(vp:app(app(B,A),C),[vp:A,coord:B,vp:C]).
combine(vp:app(A,B),[av:A,vp:B]).
combine(vp:app(A,B),[cop:A,np:B]).
combine(vp:A,[iv:A]).
combine(vp:app(A,B),[tv:A,np:B]).

combine(pp:app(A,B),[prep:A,np:B]).

combine(rc:app(A,B),[relpro:A,vp:B]).



/*************************************************************************

    File: sensitiveCurt.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(curt,[curt/0,infix/0,prefix/0]).

:- use_module(callInference,[callTPandMB/6]).

:- use_module(readLine,[readLine/1]).

:- use_module(comsemPredicates,[infix/0,
                                prefix/0,
                                memberList/2,
				printRepresentations/1]).

:- use_module(kellerStorage,[kellerStorage/2]).

:- use_module(curtPredicates,[curtHelp/0,
                              curtOutput/1,
                              updateReadings/1,
                              updateModels/1,
                              updateHistory/1,
                              clearHistory/0,
                              selectReadings/3]).


/*========================================================================
   Dynamic Predicates
========================================================================*/

:- dynamic history/1, readings/1, models/1.

history([]).
readings([]).
models([]).


/*========================================================================
   Start Curt
========================================================================*/

curt:- 
   curtTalk(run).


/*========================================================================
   Control
========================================================================*/

curtTalk(quit).

curtTalk(run):-
   readLine(Input),
   curtUpdate(Input,CurtsMoves,State), 
   curtOutput(CurtsMoves),
   curtTalk(State).


/*========================================================================
   Update Curt's Information State
========================================================================*/

curtUpdate([],[clarify],run):- !.

curtUpdate([bye],[bye],quit):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([new],[],run):- !,
   updateReadings([]),
   updateModels([]),
   clearHistory.

curtUpdate([help],[],run):- !,
   curtHelp.

curtUpdate([infix],[],run):- !,
   infix.

curtUpdate([prefix],[],run):- !,
   prefix.

curtUpdate([select,X],[],run):-
   number(X),
   readings(R1),
   selectReadings(X,R1,R2), !,
   updateReadings(R2),
   models(M1),
   selectReadings(X,M1,M2),
   updateModels(M2).

curtUpdate([readings],[],run):- !,
   readings(R),
   printRepresentations(R).

curtUpdate([models],[],run):- !,
   models(M),
   printRepresentations(M).

curtUpdate([history],[],run):- !,
   history(H),
   printRepresentations(H).

curtUpdate(Input,Moves,run):-
   kellerStorage(Input,Readings), !,
   updateHistory(Input),
   consistentReadings(Readings,[]-ConsReadings,[]-Models),
   (
      ConsReadings=[],
      Moves=[contradiction]
   ;
      \+ ConsReadings=[],
      informativeReadings(ConsReadings,[]-InfReadings),   
      (
         InfReadings=[],
         Moves=[obvious]
      ;  
         \+ InfReadings=[],
         Moves=[accept]
      ),
      combine(ConsReadings,CombinedReadings), 
      updateReadings(CombinedReadings),
      updateModels(Models)
   ).

curtUpdate(_,[noparse],run).


/*========================================================================
   Combine New Utterances with History
========================================================================*/

combine(New,New):-
   readings([]).

combine(Readings,Updated):-
   readings([Old|_]),
   findall(and(Old,New),memberList(New,Readings),Updated).


/*========================================================================
   Select Consistent Readings
========================================================================*/

consistentReadings([],C-C,M-M).

consistentReadings([New|Readings],C1-C2,M1-M2):-
   readings(Old),
   (
      consistent(Old,New,Model), !,
      consistentReadings(Readings,[New|C1]-C2,[Model|M1]-M2) 
   ;
      consistentReadings(Readings,C1-C2,M1-M2) 
   ).


/*========================================================================
   Consistency Checking calling Theorem Prover and Model Builder
========================================================================*/

consistent([Old|_],New,Model):-
   DomainSize=15,
   callTPandMB(not(and(Old,New)),and(Old,New),DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).

consistent([],New,Model):-
   DomainSize=15,
   callTPandMB(not(New),New,DomainSize,Proof,Model,Engine),
   format('~nMessage (consistency checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
   Select Informative Readings
========================================================================*/

informativeReadings([],I-I).

informativeReadings([New|L],I1-I2):-
   readings(Old),
   (
      informative(Old,New), !,
      informativeReadings(L,[New|I1]-I2) 
   ;
      informativeReadings(L,I1-I2) 
   ).


/*========================================================================
   Informativity Checking calling Theorem Prover
========================================================================*/

informative([Old|_],New):-
   DomainSize=15,
   callTPandMB(not(and(Old,not(New))),and(Old,not(New)),DomainSize,Proof,Model,Engine),
   format('~nMessage (informativity checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).

informative([],New):-
   DomainSize=15,
   callTPandMB(New,not(New),DomainSize,Proof,Model,Engine),
   format('~nMessage (informativity checking): ~p found a result.',[Engine]),
   \+ Proof=proof, Model=model([_|_],_).


/*========================================================================
   Info
========================================================================*/

info:-
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n> sensitiveCurtFOL.pl, by Patrick Blackburn and Johan Bos    <',[]),
   format('~n>                                                            <',[]),
   format('~n> ?- curt.                - start a dialogue with Curt       <',[]),
   format('~n>                                                            <',[]),
   format('~n> Type "help" to get more information about features         <',[]),
   format('~n> ---------------------------------------------------------- <',[]),
   format('~n~n',[]).



/*========================================================================
   Display info at start
========================================================================*/

:- info.



/*************************************************************************

    File: sentenceTestSuite.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(sentenceTestSuite,[sentence/2]).


/*========================================================================
   Sentences
========================================================================*/

sentence([a,man,walks],1).

sentence([mia,dances],1).

sentence([if,vincent,dances,then,mia,dances],1).

sentence([who,dances],1).

sentence([which,robber,dies],1).

sentence([mia,or,vincent,dances],1).

sentence([every,customer,smokes],1).

sentence([a,customer,smokes],1).

sentence([mia,or,a,man,dances],1).

sentence([every,woman,or,a,man,dances],2).

sentence([every,man,or,woman,dances],1).

sentence([every,man,that,dances,smokes],1).

sentence([every,customer,in,a,restaurant,smokes],2).

sentence([mia,knows,a,man],1).

sentence([if,butch,shoots,vincent,then,vincent,dies],1).

sentence([who,likes,mia],1).

sentence([which,boxer,shoots,vincent],1).

sentence([which,boxer,shoots,a,criminal],1).

sentence([mia,or,vincent,eats,a,quarter,pounder,with,cheese],2).

sentence([every,customer,drinks,a,five,dollar,shake],2).

sentence([a,customer,knows,mia,or,a,man],2).

sentence([vincent,knows,every,woman,or,a,man],2).

sentence([vincent,knows,every,man,or,woman],1).

sentence([mia,dates,every,man,that,dances],1).

sentence([a,robber,likes,every,customer,in,a,restaurant],5).

sentence([butch,growls,or,dies],1).

sentence([every,boxer,growls,or,dies],1).

sentence([butch,kills,a,criminal,or,dies],1).

sentence([butch,kills,a,criminal,or,shoots,vincent],1).

sentence([butch,kills,a,criminal,or,shoots,a,criminal],2).

sentence([butch,is,a,boxer],1).

sentence([butch,is,not,vincent],1).

sentence([butch,does,not,die],1).

sentence([butch,does,die],1).

sentence([a,boxer,does,not,die],2).

sentence([every,boxer,does,not,die],2).

sentence([vincent,knows,mia,or,does,not,dance],1).

sentence([vincent,does,not,smoke,or,dance],1).

sentence([a,man,does,not,smoke,or,dance],2).

sentence([every,customer,in,a,restaurant,eats,a,big,kahuna,burger],5).

sentence([every,customer,in,a,restaurant,does,not,eat,a,big,kahuna,burger],18).

sentence([every,man,in,a,restaurant,knows,a,woman,with,a,car],14).

sentence([if,every,man,knows,a,woman,then,every,woman,knows,a,man],4).

sentence([vincent,eats,a,big,kahuna,burger],1).

sentence([either,vincent,eats,a,big,kahuna,burger,or,jules,smokes],1).



/*************************************************************************

    File: situationalKnowledge.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(situationalKnowledge,[situationalKnowledge/1]).

:- dynamic situationalKnowledge/1.

/*========================================================================
   Axioms for Situational Knowledge
========================================================================*/

%% There are at least two different cars
%%
%situationalKnowledge(Axiom):-
%   Axiom = some(X,some(Y,and(car(X),and(car(Y),not(eq(X,Y)))))).


/*************************************************************************

    File: worldKnowledge.pl
    Copyright (C) 2004,2005,2006 Patrick Blackburn & Johan Bos

    This file is part of BB1, version 1.3 (November 2006).

    BB1 is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2 of the License, or
    (at your option) any later version.

    BB1 is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with BB1; if not, write to the Free Software Foundation, Inc., 
    59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

*************************************************************************/

:- module(worldKnowledge,[worldKnowledge/3]).

/*========================================================================
   Axioms for World Knowledge
========================================================================*/


%% Nothing can have itself, and no object can be part of two different objects
%%
worldKnowledge(have,2,Axiom):- 
   Axiom = and(not(some(X,have(X,X))),all(X,all(Y,
               imp(some(Z,and(object(X),and(object(Y),and(object(Z),
                   and(have(X,Z),have(Y,Z)))))),eq(X,Y))))).



worldKnowledge(husband,1,Axiom):- 
   Axiom = all(A,imp(husband(A),married(A))).

worldKnowledge(wife,1,Axiom):- 
   Axiom = all(A,imp(wife(A),married(A))).


